---
title: Debugging
sidebar_label: "Debugging"
sidebar_position: 1100
description: "Debugging the Agent component"
---

## Playground에서 디버깅하기

일반적으로 [Playground](./playground.mdx)는 무슨 일이 일어나고 있는지에 대한 많은 정보를 제공하지만, 그것이 불충분한 경우 다른 옵션이 있습니다.

## LLM 호출의 원시 요청 및 응답 로깅하기

LLM의 원시 요청 및 응답을 로그하기 위해 에이전트에 `rawRequestResponseHandler`를 제공할 수 있습니다.

이를 사용하여 요청 및 응답을 테이블에 로그하거나, [로그 스트리밍](https://docs.convex.dev/production/integrations/log-streams/)과 함께 콘솔 로그를 사용하여 Axiom 또는 다른 로깅 서비스를 통해 디버깅 및 검색할 수 있습니다.

```ts
const supportAgent = new Agent(components.agent, {
  ...
  rawRequestResponseHandler: async (ctx, { request, response }) => {
    console.log("request", request);
    console.log("response", response);
  },
});
```

## contextHandler를 통해 컨텍스트 메시지 로깅하기

LLM이 정확히 무엇을 받고 있는지 궁금하다면 contextHandler를 통해 컨텍스트 메시지를 로그할 수 있습니다.

```ts
const supportAgent = new Agent(components.agent, {
  ...
  contextHandler: async (ctx, { allMessages }) => {
    console.log("context", allMessages);
    return allMessages;
  },
});
```

## 대시보드에서 데이터베이스 검사하기

대시보드의 Data 탭으로 이동하여 테이블 목록 위에서 에이전트 컴포넌트를 선택하면 에이전트 데이터를 볼 수 있습니다. 테이블 구성은 [스키마](https://github.com/get-convex/agent/blob/main/src/component/schema.ts)와 일치합니다. 가장 유용한 테이블은 다음과 같습니다:

- `threads`는 스레드당 하나의 행을 가집니다
- `messages`는 각 ModelMessage에 대해 별도의 행을 가집니다 - 예: 사용자 메시지, 어시스턴트 툴 호출, 툴 결과, 어시스턴트 메시지 등. 가장 중요한 필드는 연결된 에이전트를 나타내는 `agentName`, `status`, 메시지 순서를 지정하는 데 사용되는 `order` 및 `stepOrder`, LLM에 전달되는 것과 대략 일치하는 `message`입니다.
- `streamingMessages`는 정리될 때까지 각 스트리밍 메시지에 대한 항목을 가집니다. ID를 가져와 연결된 `streamDeltas` 테이블을 볼 수 있습니다.
- `files`는 파일 스토리지에 저장된 메시지에서 전송된 콘텐츠에서 에이전트가 추적하는 파일을 캡처합니다.

## 문제 해결

### `components.agent`에 대한 타입 오류

`components.agent`에 대한 타입 오류가 발생하면 `npx convex dev`를 실행하여 컴포넌트에 대한 코드를 생성했는지 확인하세요. 라이브러리에서 예상하는 타입은 npm 라이브러리에 있으며, `components.agent`의 타입은 현재 프로젝트의 생성된 코드에서 가져옵니다(`npx convex dev`를 통해).

### 순환 종속성

워크플로우의 반환 값이 다른 Convex 함수에 종속되면 `internal.foo.bar` 방식의 함수 지정으로 인해 순환 종속성이 발생할 수 있습니다. 이를 수정하는 방법은 워크플로우의 반환 값을 명시적으로 타입 지정하는 것입니다. 의심스러운 경우 다음과 같이 더 많은 `handler` 함수에 반환 타입을 추가하세요:

```ts
export const supportAgentWorkflow = workflow.define({
  args: { prompt: v.string(), userId: v.string(), threadId: v.string() },
  // highlight-next-line
  handler: async (step, { prompt, userId, threadId }): Promise<string> => {
    // ...
  },
});

// 일반 함수도 마찬가지입니다:
export const myFunction = action({
  args: { prompt: v.string() },
  // highlight-next-line
  handler: async (ctx, { prompt }): Promise<string> => {
    // ...
  },
});
```
