---
title: 에이전트 컴포넌트와 RAG (검색 증강 생성)
sidebar_label: "RAG"
sidebar_position: 700
description: "Convex 에이전트 컴포넌트와 함께 RAG를 사용하는 방법 예제"
---

에이전트 컴포넌트에는 하이브리드 텍스트 및 벡터 검색으로 메시지 기록을 검색하는 기본 제공 기능이 있습니다. RAG 컴포넌트를 사용하여 다른 데이터를 사용하여 컨텍스트를 검색할 수도 있습니다.

## RAG란 무엇인가요?

검색 증강 생성(RAG)은 LLM이 사용자 지정 지식 베이스를 검색하여 질문에 답변할 수 있도록 하는 기술입니다.

RAG는 대규모 언어 모델(LLM)의 성능과 지식 검색을 결합합니다. 모델의 학습 데이터에만 의존하는 대신 RAG를 통해 AI가 다음을 수행할 수 있습니다:

- 사용자 지정 문서 및 지식 베이스 검색
- 질문에 답변하기 위한 관련 컨텍스트 검색
- 더 정확하고 최신이며 도메인별 응답 제공
- 출처를 인용하고 사용된 정보 설명

## RAG 컴포넌트

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/dGmtAmdAaFs?si=ce-M8pt6EWDZ8tfd"
    title="RAG Component YouTube Video"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

RAG 컴포넌트는 검색할 수 있는 데이터를 추가할 수 있는 Convex 컴포넌트입니다. 데이터를 청크로 나누고 벡터 검색에 사용할 임베딩을 생성합니다. 자세한 내용은 [RAG 컴포넌트 문서](https://convex.dev/components/rag)를 참조하세요. 주요 기능은 다음과 같습니다:

- **네임스페이스:** 검색 도메인을 격리하기 위해 사용자별 또는 팀별 데이터에 네임스페이스를 사용합니다.
- **콘텐츠 추가**: 키별로 텍스트 콘텐츠를 추가하거나 교체합니다.
- **시맨틱 검색**: 구성 가능한 임베딩 모델을 사용한 벡터 기반 검색
- **사용자 지정 필터링:** 효율적인 벡터 검색을 위해 각 문서에 필터를 정의합니다.
- **청크 컨텍스트**: 더 나은 컨텍스트를 위해 주변 청크를 가져옵니다.
- **중요도 가중치**: 문서별 벡터 검색 결과에 영향을 미치는 0에서 1까지의 "중요도"를 제공하여 콘텐츠에 가중치를 부여합니다.
- **청크 유연성:** 자체 문서 청킹을 가져오거나 기본값을 사용합니다.
- **우아한 마이그레이션**: 중단 없이 콘텐츠 또는 전체 네임스페이스를 마이그레이션합니다.

import { ComponentCardList } from "@site/src/components/ComponentCard";

<ComponentCardList
  items={[
    {
      title: "RAG (검색 증강 생성)",
      description:
        "임베딩을 사용하여 LLM을 프롬프트하기 위해 관련 콘텐츠를 문서에서 검색합니다.",
      href: "https://www.convex.dev/components/rag",
    },
  ]}
/>

## RAG 접근 방식

이 디렉토리에는 RAG를 구현하는 두 가지 접근 방식이 있습니다:

### 1. 프롬프트 기반 RAG

시스템이 사용자 쿼리에 대한 관련 컨텍스트를 자동으로 검색하는 간단한 구현입니다.

- 메시지 기록에는 원래 사용자 프롬프트와 응답만 포함되며 컨텍스트는 포함되지 않습니다.
- 컨텍스트를 조회하고 사용자 프롬프트에 삽입합니다.
- 사용자의 질문이 _항상_ 추가 컨텍스트의 이점을 얻을 것으로 알고 있는 경우 잘 작동합니다.

예제 코드는 전체 코드를 보려면 [ragAsPrompt.ts](https://github.com/get-convex/agent/blob/main/example/convex/rag/ragAsPrompt.ts)를 참조하세요. 가장 간단한 버전은 다음과 같습니다:

```ts
const context = await rag.search(ctx, {
  namespace: "global",
  query: userPrompt,
  limit: 10,
});

const result = await agent.generateText(
  ctx,
  { threadId },
  {
    prompt: `# Context:\n\n ${context.text}\n\n---\n\n# Question:\n\n"""${userPrompt}\n"""`,
  },
);
```

### 2. 툴 기반 RAG

LLM은 컨텍스트를 검색하는 툴을 제공하여 컨텍스트를 검색하거나 새 정보를 추가할 시기를 지능적으로 결정할 수 있습니다.

- 메시지 기록에는 원래 사용자 프롬프트와 메시지 기록이 포함됩니다.
- 툴 호출 및 응답 후 메시지 기록에는 LLM이 참조할 툴 호출 및 응답이 포함됩니다.
- LLM은 컨텍스트를 검색하거나 새 정보를 추가할 시기를 결정할 수 있습니다.
- 에이전트가 동적으로 검색할 수 있도록 하려는 경우 잘 작동합니다.

코드는 [ragAsTools.ts](https://github.com/get-convex/agent/blob/main/example/convex/rag/ragAsTools.ts)를 참조하세요. 가장 간단한 버전은 다음과 같습니다:

```ts
searchContext: createTool({
  description: "Search for context related to this user prompt",
  args: z.object({ query: z.string().describe("Describe the context you're looking for") }),
  handler: async (ctx, { query }) => {
    const context = await rag.search(ctx, { namespace: userId, query });
    return context.text;
  },
}),
```

## 주요 차이점

| 기능            | 기본 RAG                    | 툴 기반 RAG                         |
| ------------------ | ---------------------------- | -------------------------------------- |
| **컨텍스트 검색** | 항상 검색              | AI가 검색 시기 결정              |
| **컨텍스트 추가** | 별도 함수를 통한 수동 | AI가 대화 중 컨텍스트 추가 가능 |
| **유연성**    | 간단하고 예측 가능          | 지능적이고 적응적                  |
| **사용 사례**       | FAQ 시스템, 문서 검색 | 동적 지식 관리           |
| **예측 가능성** | 코드로 정의              | AI가 너무 많이 또는 적게 쿼리할 수 있음        |

## 콘텐츠 수집

전반적으로 RAG 컴포넌트는 텍스트와 함께 작동합니다. 그러나 파싱 툴을 사용하거나 LLM에 요청하여 다른 파일을 텍스트로 변환할 수 있습니다.

### 이미지 파싱

이미지 파싱은 LLM에서 이상하게 잘 작동합니다. `generateText`를 사용하여 이미지를 설명하고 전사한 다음 해당 설명을 사용하여 관련 컨텍스트를 검색할 수 있습니다. 그리고 관련 이미지를 저장하여 검색을 통해 검색한 후 원본 파일을 전달할 수 있습니다.

[여기에서 예제를 참조하세요](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L28-L42).

```ts
const description = await thread.generateText({
  message: {
    role: "user",
    content: [{ type: "image", data: url, mimeType: blob.type }],
  },
});
```

### PDF 파싱

PDF 파싱의 경우 브라우저에서 Pdf.js를 사용하는 것이 좋습니다.

**왜 서버 측이 아닌가요?**

PDF를 여는 것은 수백 MB의 메모리를 사용할 수 있으며 큰 pdfjs 번들을 다운로드해야 합니다. 일반적으로 실제로는 동적으로 가져옵니다. 서버 측에서 모든 함수 호출마다 해당 번들을 로드하고 싶지 않을 것이며 서버리스 환경에서는 메모리 사용이 더 제한적입니다. 브라우저에 이미 파일이 있는 경우 무거운 작업을 수행하기에 꽤 좋은 환경입니다(그리고 무료입니다!).

[RAG 데모](https://github.com/get-convex/rag/blob/main/example/src/pdfUtils.ts#L14)에 예제가 있으며, [여기 UI에서 사용됨](https://github.com/get-convex/rag/blob/main/example/src/components/UploadSection.tsx#L51), [Pdf.js가 정적으로 제공됨](https://github.com/get-convex/rag/blob/main/example/public/pdf-worker/).

비용이나 대기 시간에 대해 걱정하지 않고 서버 측에서 정말로 하고 싶다면 LLM에 전달할 수 있지만 큰 파일의 경우 시간이 오래 걸립니다.

[여기에서 예제를 참조하세요](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L50-L65).

### 텍스트 파일 파싱

일반적으로 LLM이 이해할 수 있는 자연 구조가 있는 코드나 마크다운 또는 모든 것에 대해 텍스트 파일을 직접 사용할 수 있습니다.

그러나 좋은 임베딩을 얻으려면 LLM을 다시 사용하여 텍스트를 더 구조화된 형식으로 변환할 수 있습니다.

[여기에서 예제를 참조하세요](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L68-L89).

## 실제 예제

이러한 예제를 실제로 보려면 [RAG 예제](https://github.com/get-convex/rag/blob/main/example/convex/example.ts)를 확인하세요.

- RAG 컴포넌트에 텍스트, PDF 및 이미지 콘텐츠 추가
- 컨텍스트를 기반으로 검색 및 텍스트 생성.
- 검색으로 생성된 컨텍스트 검사.
- 생성된 문서 청크 탐색.
- 전역, 사용자별 또는 사용자 지정 필터로 검색을 시도합니다.

예제를 다음과 같이 실행합니다:

```bash
git clone https://github.com/get-convex/rag.git
cd rag
npm run setup
npm run example
```
