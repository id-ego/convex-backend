---
title: 워크플로우
sidebar_label: "워크플로우"
sidebar_position: 800
description: "에이전트 컴포넌트를 위한 장기 실행 워크플로우 정의하기"
---

에이전틱 워크플로우는 두 가지 요소로 분해할 수 있습니다:

1. LLM 프롬프트하기(메시지 기록, 컨텍스트 등 포함).
2. LLM의 응답으로 무엇을 할지 결정하기.

일반적으로 여러 단계가 포함되거나, 다음에 무엇을 할지 동적으로 결정하거나, 장기 실행되거나, 비즈니스 로직과 LLM 호출이 혼합되어 있을 때 워크플로우라고 부릅니다.

툴 호출과 MCP는 LLM의 응답이 취해야 할 조치에 대한 특정 요청인 경우에 작동합니다. 사용 가능한 툴 목록과 호출 결과는 LLM에 대한 프롬프트에 사용됩니다.

워크플로우의 특히 강력한 형태는 장기 실행될 수 있고, 서버 재시작을 견디며, 재시도, 멱등성 및 완료에 대한 강력한 보장을 가진 [내구성 함수](https://stack.convex.dev/durable-workflows-and-strong-guarantees)로 모델링할 수 있는 것입니다.

이것의 가장 간단한 버전은 먼저 날씨 예보를 가져온 다음 날씨를 기반으로 패션 조언을 받는 것과 같이 미리 정의된 몇 단계를 수행하는 것일 수 있습니다. 코드 예제는 [workflows/chaining.ts](https://github.com/get-convex/agent/blob/main/example/convex/workflows/chaining.ts)를 참조하세요.

```ts
export const getAdvice = action({
  args: { location: v.string(), threadId: v.string() },
  handler: async (ctx, { location, threadId }) => {
    // This uses tool calls to get the weather forecast.
    await weatherAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What is the weather in ${location}?` },
    );
    // This includes previous message history from the thread automatically and
    // uses tool calls to get user-specific fashion advice.
    await fashionAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What should I wear based on the weather?` },
    );
    // We don't need to return anything, since the messages are saved
    // automatically and clients will get the response via subscriptions.
  },
});
```

## 신뢰할 수 있는 워크플로우 구축하기

LLM으로 작업할 때 일반적인 함정 중 하나는 신뢰성이 부족하다는 것입니다. API 제공업체에 중단이 있고 LLM이 불안정할 수 있습니다. 신뢰할 수 있는 워크플로우를 구축하려면 세 가지 속성이 필요한 경우가 많습니다:

1. 신뢰할 수 있는 재시도
2. 로드 밸런싱
3. 다단계 워크플로우를 위한 내구성 및 멱등성

다행히 이러한 속성을 활용할 수 있는 Convex 컴포넌트가 있습니다.

### 재시도

기본적으로 Convex mutation은 이러한 속성을 기본적으로 가지고 있습니다. 그러나 LLM을 호출하려면 부작용과 네트워크 호출을 사용해야 하므로 액션을 사용해야 합니다. 재시도에만 관심이 있다면 [Action Retrier](https://convex.dev/components/retrier) 컴포넌트를 사용할 수 있습니다.

그러나 계속 읽으세요. [Workpool](https://convex.dev/components/workpool) 및 [Workflow](https://convex.dev/components/workflow) 컴포넌트가 재시도를 포함한 더 강력한 솔루션을 제공하기 때문입니다.

### 로드 밸런싱

서버리스 환경에서 장기 실행 액션을 사용하면 많은 리소스를 소비할 수 있습니다. 그리고 RAG를 위한 데이터 수집이나 다른 급증하는 워크로드와 같은 작업으로 리소스가 부족할 위험이 있습니다. 이를 완화하기 위해 [Workpool](https://convex.dev/components/workpool) 컴포넌트를 사용할 수 있습니다. 동시 작업자 수에 제한을 설정하고 구성 가능한 재시도와 최종 성공/실패를 처리하는 콜백을 사용하여 비동기로 작업을 추가할 수 있습니다.

그러나 다단계 워크플로우도 관리하려면 기본적으로 재시도 및 로드 밸런싱을 제공하는 [Workflow](https://convex.dev/components/workflow) 컴포넌트를 사용해야 합니다.

### 다단계 워크플로우를 위한 내구성 및 멱등성

중간에 실패할 수 있는 다단계 워크플로우를 수행할 때 중복 작업 없이 중단된 위치에서 워크플로우를 재개할 수 있어야 합니다. [Workflow](https://convex.dev/components/workflow)는 [Workpool](https://convex.dev/components/workpool)을 기반으로 재시도 및 지연과 함께 장기 실행 함수의 내구성 실행을 제공합니다.

워크플로우의 각 단계가 실행되고 결과가 기록됩니다. 서버가 중간에 실패하더라도 구성 가능한 재시도 설정으로 최신 불완전 단계에서 재개됩니다.

## 장기 실행 내구성 워크플로우를 위한 워크플로우 컴포넌트 사용하기

[워크플로우 컴포넌트](https://convex.dev/components/workflow)는 장기 실행, 내구성 워크플로우를 구축하는 좋은 방법입니다. 재시도와 최종 완료 보장, 서버 재시작 견딤 등을 처리합니다. 내구성 워크플로우에 대한 자세한 내용은 [이 Stack 게시물](https://stack.convex.dev/durable-workflows-and-strong-guarantees)을 참조하세요.

에이전트와 함께 워크플로우를 사용하려면 워크플로우가 실행할 수 있는 개별 멱등 단계를 실행할 수 있으며, 각 단계에는 구성 가능한 재시도가 있고 워크플로우가 최종적으로 완료된다는 보장이 있습니다. 워크플로우 중간에 서버가 충돌하더라도 워크플로우는 중단된 위치에서 다시 시작하여 다음 단계를 실행합니다. 단계가 실패하고 워크플로우에서 포착되지 않으면 워크플로우의 onComplete 핸들러가 오류 결과를 받습니다.

### 에이전트를 Convex 액션으로 노출하기

에이전트의 기능을 워크플로우의 단계로 사용할 Convex 함수로 노출할 수 있습니다.

`createThread`와 유사한 독립 실행형 mutation으로 스레드를 생성하려면:

```ts
export const createThread = supportAgent.createThreadMutation();
```

`thread.generateText`와 유사하게 스레드에서 텍스트를 생성하는 액션의 경우:

```ts
export const getSupport = supportAgent.asTextAction({
  stopWhen: stepCountIs(10),
});
```

객체를 생성하는 독립 실행형 액션을 노출할 수도 있습니다.

```ts
export const getStructuredSupport = supportAgent.asObjectAction({
  schema: z.object({
    analysis: z.string().describe("A detailed analysis of the user's request."),
    suggestion: z.string().describe("A suggested action to take."),
  }),
});
```

`agent.saveMessages`와 유사하게 메시지를 명시적으로 mutation으로 저장하려면:

```ts
export const saveMessages = supportAgent.asSaveMessagesMutation();
```

이것은 멱등성에 유용합니다. 먼저 사용자의 메시지를 만든 다음 프롬프트 대신 기존 messageId를 전달하여 재시도가 있는 신뢰할 수 없는 액션에서 응답을 생성할 수 있기 때문입니다.

### 워크플로우 내에서 에이전트 액션 사용하기

[워크플로우 컴포넌트](https://convex.dev/components/workflow)를 사용하여 에이전트 플로우를 실행할 수 있습니다. 재시도와 최종 완료 보장, 서버 재시작 견딤 등을 처리합니다. 내구성 워크플로우에 대한 자세한 내용은 [이 Stack 게시물](https://stack.convex.dev/durable-workflows-and-strong-guarantees)을 참조하세요.

```ts
const workflow = new WorkflowManager(components.workflow);

export const supportAgentWorkflow = workflow.define({
  args: { prompt: v.string(), userId: v.string() },
  handler: async (step, { prompt, userId }) => {
    const { threadId } = await step.runMutation(internal.example.createThread, {
      userId,
      title: "Support Request",
    });
    const suggestion = await step.runAction(internal.example.getSupport, {
      threadId,
      userId,
      prompt,
    });
    const { object } = await step.runAction(
      internal.example.getStructuredSupport,
      {
        userId,
        message: suggestion,
      },
    );
    await step.runMutation(internal.example.sendUserMessage, {
      userId,
      message: object.suggestion,
    });
  },
});
```

코드는 [workflows/chaining.ts](https://github.com/get-convex/agent/blob/main/example/convex/workflows/chaining.ts)를 참조하세요.

## 복잡한 워크플로우 패턴

여기에는 간단한 워크플로우의 예만 있지만 에이전트 컴포넌트로 구축할 수 있는 많은 복잡한 패턴이 있습니다:

- LLM 호출 또는 벡터 검색을 기반으로 에이전트로 동적 라우팅
- LLM 호출로 팬아웃한 다음 결과 결합
- 여러 에이전트 오케스트레이션
- 추론 및 행동 주기(ReAct)
- 서로 메시지를 주고받는 에이전트 네트워크 모델링
- 일시 중지 및 재개할 수 있는 워크플로우

import { ComponentCardList } from "@site/src/components/ComponentCard";

<ComponentCardList
  items={[
    {
      title: "Action Retrier",
      description:
        "신뢰할 수 없는 외부 서비스 호출에 신뢰성을 추가합니다. 성공할 때까지 지수 백오프로 멱등 호출을 재시도합니다.",
      href: "https://www.convex.dev/components/retrier",
    },
    {
      title: "Workpool",
      description:
        "Action Retrier를 기반으로 병렬 처리 제한과 재시도를 제공하여 많은 수의 외부 요청을 효율적으로 관리합니다.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Workflow",
      description:
        "Workpool을 기반으로 재시도 및 지연과 함께 장기 실행 함수의 내구성 실행을 제공합니다.",
      href: "https://www.convex.dev/components/workflow",
    },
  ]}
/>
