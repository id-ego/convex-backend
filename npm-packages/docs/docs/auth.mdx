---
title: Authentication
sidebar_position: 30
description: Add authentication to your Convex app.
hide_table_of_contents: true
pagination_prev: file-storage
---

Convex 배포 엔드포인트는 공개 인터넷에 노출되며, 클라이언트가 자신의 신원에 대해 주장하는 내용은 사용자를 식별하고 볼 수 있거나 편집할 수 있는 데이터를 제한하기 위해 인증되어야 합니다.

Convex는 WebSocket 연결이나 RPC를 인증하기 위해 JWT 형태의 OpenID Connect(OAuth 기반) ID 토큰을 사용하기 때문에 대부분의 인증 제공자와 호환됩니다. 이러한 JWT는 이를 검증하기 위한 적절한 OAuth 엔드포인트를 구현하는 모든 서비스(자체 Convex 백엔드 포함)에서 제공될 수 있습니다.

## 타사 인증 플랫폼

타사 인증 제공자와 Convex 통합을 활용하면 가장 포괄적인 인증 솔루션을 제공합니다. 다른 서비스를 통합하면 기본적인 인증 기능 외에도 패스키, 이중 인증, 스팸 방지 등과 같은 다양한 기능을 제공합니다.

- [Clerk](/auth/clerk.mdx)는 Next.js 및 React Native를 훌륭하게 지원합니다
- [WorkOS AuthKit](/auth/authkit/index.mdx)는 B2B 앱용으로 제작되었으며 최대 100만 사용자까지 무료입니다
- [Auth0](/auth/auth0.mdx)는 더 많은 기능을 갖춘 더 확립된 서비스입니다
- [사용자 정의 인증 통합](/auth/advanced/custom-auth.mdx)을 사용하면 OpenID Connect 호환 ID 제공자를 인증에 사용할 수 있습니다

이 중 하나를 통합한 후, [함수](/auth/functions-auth.mdx)에서 인증 정보에 액세스하고 [데이터베이스](/auth/database-auth.mdx)에 사용자 정보를 저장하는 방법에 대해 자세히 알아보세요.

## Convex Auth 라이브러리

클라이언트 측 React 및 React Native 모바일 앱의 경우 [Convex Auth](/auth/convex-auth.mdx) 라이브러리를 사용하여 Convex에서 직접 인증을 구현할 수 있습니다. 이 [npm 패키지](https://github.com/get-convex/convex-auth)는 Convex 배포에서 실행되며 소셜 ID 제공자, 일회용 이메일 또는 SMS 액세스 코드, 또는 비밀번호를 통해 사용자 정의 가입/로그인 흐름을 구축하는 데 도움이 됩니다.

Convex Auth는 베타 버전입니다(완성되지 않았으며 이전 버전과 호환되지 않는 방식으로 변경될 수 있음). 타사 인증 통합만큼 많은 기능을 제공하지는 않습니다. 다른 서비스에 가입할 필요가 없기 때문에 인증을 설정하고 실행하는 가장 빠른 방법입니다.

<BetaAdmonition feature="Convex Auth" verb="is" />

Next.js 지원은 현재 활발하게 개발 중입니다. 이 실험적 지원을 테스트하는 데 도움을 주고 싶으시다면 [사용해 보세요](https://labs.convex.dev/auth)!

## 디버깅

문제가 발생하면 [디버깅](/auth/debug.mdx) 가이드를 참조하세요.

## 서비스 인증

제어하는 서버나 타사 서비스는 Convex 함수를 호출할 수 있지만 OpenID JWT를 얻을 수 없고 종종 특정 사용자의 작업을 나타내지 않습니다.

예를 들어 Python으로 작성된 [Modal](https://modal.com/) 서버에서 일부 추론을 실행한다고 가정해 봅시다. 해당 서버가 Convex 쿼리를 구독할 때 특정 최종 사용자의 자격 증명으로 수행하는 것이 아니라, 예를 들어 대화 요약 및 번역과 같은 추론 작업이 필요한 모든 사용자에 대한 관련 작업을 찾고 있습니다.

외부 서비스에 Convex 쿼리, 뮤테이션 및 액션에 대한 액세스를 제공하려면 다른 작업을 수행하기 전에 환경 변수의 공유 비밀을 확인하는 인터넷에서 액세스할 수 있는 공개 함수를 작성할 수 있습니다.

## 권한 부여

Convex는 전통적인 3계층 애플리케이션 구조를 가능하게 합니다: 앱용 클라이언트/UI, 사용자 요청을 처리하는 백엔드, 쿼리를 위한 데이터베이스. 이 아키텍처를 사용하면 코드에서 정의할 수 있는 모든 권한 부여 규칙에 대해 모든 공개 요청을 확인할 수 있습니다.

즉, Convex는 Firebase나 Supabase와 같은 클라이언트 지향 데이터베이스에서 필요한 RLS와 같은 독단적인 권한 부여 프레임워크가 필요하지 않습니다. 이러한 유연성을 통해 필요에 맞는 [권한 부여 프레임워크](https://en.wikipedia.org/wiki/Authorization)를 구축하고 사용할 수 있습니다.

그렇긴 하지만, 가장 일반적인 방법은 각 공개 함수의 시작 부분에서 사용자가 로그인했는지, 요청한 작업을 수행할 수 있는지 확인하는 코드를 작성하는 것입니다.

예를 들어, 다음 함수는 현재 인증된 사용자만 자신의 사용자 이미지를 제거할 수 있도록 강제합니다:

```typescript
export const removeUserImage = mutation({
  args: {},
  handler: async (ctx) => {
    // highlight-next-line
    const userId = await getAuthUserId(ctx);
    // highlight-next-line
    if (!userId) {
      // highlight-next-line
      return;
      // highlight-next-line
    }
    ctx.db.patch(userId, { imageId: undefined, image: undefined });
  },
});
```

<StackPosts query="authentication" />
