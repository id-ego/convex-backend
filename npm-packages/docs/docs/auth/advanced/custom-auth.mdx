---
title: "사용자 정의 OIDC 공급자"
sidebar_label: "사용자 정의 OIDC 공급자"
sidebar_position: 3
description:
  "사용자 정의 인증 구성 및 ConvexProviderWithAuth를 사용하여 Convex를 OpenID Connect ID 공급자와 통합합니다."
---

**참고: 이것은 고급 기능입니다!** [지원되는 타사 인증 공급자](/auth.mdx) 사용을 권장합니다.

Convex는 [OpenID Connect](https://openid.net/connect/) 프로토콜을 지원하는 모든 ID 공급자와 통합할 수 있습니다. 최소한 공급자가 [ID 토큰](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)을 발급할 수 있고 해당 [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)를 노출해야 합니다.
ID 토큰은 클라이언트에서 Convex 백엔드로 전달되며, 백엔드는 토큰이 유효한지 확인하고 [함수에서의 인증](/auth/functions-auth.mdx)에 설명된 대로 토큰에 포함된 사용자 정보를 쿼리할 수 있게 합니다.

## 서버 측 통합

[Clerk](/auth/clerk.mdx) 및 [Auth0](/auth/auth0.mdx)와 마찬가지로, 백엔드는 발급자의 도메인과 특정 ID 공급자의 애플리케이션 ID를 알아야 합니다.

`convex/auth.config.ts` 파일에 다음을 추가하세요:

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      domain: "https://your.issuer.url.com",
      applicationID: "your-application-id",
    },
  ],
} satisfies AuthConfig;
```

`applicationID` 속성은 JWT의 `aud` 필드와 정확히 일치해야 하며, `domain` 속성은 JWT의 `iss` 필드와 정확히 일치해야 합니다. [jwt.io](https://jwt.io/)와 같은 도구를 사용하여 JWT를 보고 이러한 필드가 정확히 일치하는지 확인하세요.

여러 공급자가 제공되면 위 기준을 충족하는 첫 번째 공급자가 사용됩니다.

`aud` 필드가 있는 토큰을 얻을 수 없는 경우 [사용자 정의 JWT](/auth/advanced/custom-jwt.mdx)를 대신 구성해야 합니다. 토큰이 OIDC ID 토큰인지 확실하지 않다면 [스펙](https://openid.net/specs/openid-connect-core-1_0-final.html#rfc.section.2)에서 필수 필드 목록을 확인하세요.

OIDC는 `${domain}/.well-known/jwks.json` 및 `${domain}/.well-known/openid-configuration` 경로가 필요합니다. `domain`은 `https://your.issuer.url.com/api/auth`와 같은 경로를 포함할 수 있습니다. 이는 타사 인증 공급자에서는 일반적이지 않지만 자체 서버에서 OIDC를 구현하는 경우 유용할 수 있습니다.

## 클라이언트 측 통합

### 새 ID 공급자 통합

[`ConvexProviderWithAuth`](/api/modules/react#convexproviderwithauth) 컴포넌트는 Convex가 [Clerk](/auth/clerk.mdx) 및 [Auth0](/auth/auth0.mdx)에 제공하는 것과 유사한 인증 통합을 구축하기 위한 편리한 추상화를 제공합니다.

다음 예제에서는 가상의 "ProviderX"와의 통합을 구축합니다. ProviderX의 React 통합에는 `AuthProviderXReactProvider`와 `useProviderXAuth` 훅이 포함됩니다.

먼저 앱의 루트에서 `ConvexProvider`를 `ConvexProviderWithAuth`를 감싸는 `AuthProviderXReactProvider`로 교체합니다:

```jsx title="src/index.js"
import { AuthProviderXReactProvider } from "providerX";
import { ConvexProviderWithAuth } from "convex/react";

root.render(
  <StrictMode>
    <AuthProviderXReactProvider>
      <ConvexProviderWithAuth client={convex} useAuth={useAuthFromProviderX}>
        <App />
      </ConvexProviderWithAuth>
    </AuthProviderXReactProvider>
  </StrictMode>,
);
```

우리가 실제로 필요한 것은 `ConvexProviderWithAuth` 컴포넌트에 전달되는 `useAuthFromProviderX` 훅을 구현하는 것입니다.

이 `useAuthFromProviderX` 훅은 인증 공급자 API와 [`ConvexReactClient`](/api/classes/react.ConvexReactClient) API 사이의 변환을 제공하며, 궁극적으로 ID 토큰이 Convex 백엔드로 전달되도록 합니다.

```jsx title="src/ConvexProviderWithProviderX.js"
function useAuthFromProviderX() {
  const { isLoading, isAuthenticated, getToken } = useProviderXAuth();
  const fetchAccessToken = useCallback(
    async ({ forceRefreshToken }) => {
      // 여기서 ID 토큰을 가져오거나 null을 반환하기 위한 변환을 수행할 수 있습니다
      // `forceRefreshToken`이 true일 때 새 토큰을 가져오도록 하세요
      return await getToken({ ignoreCache: forceRefreshToken });
    },
    // `getToken`이 올바르게 메모이제이션되지 않은 경우
    // 이 의존성 배열에서 제거하세요
    [getToken],
  );
  return useMemo(
    () => ({
      // 인증 공급자가 로딩 상태인지 여부
      isLoading: isLoading,
      // 인증 공급자가 사용자를 로그인시켰는지 여부
      isAuthenticated: isAuthenticated ?? false,
      // ID 토큰을 가져오는 비동기 함수
      fetchAccessToken,
    }),
    [isLoading, isAuthenticated, fetchAccessToken],
  );
}
```

### 새 공급자 사용

위의 단계를 성공적으로 따르면 이제 인증 상태를 확인하기 위한 표준 Convex 유틸리티를 사용할 수 있습니다: [`useConvexAuth()`](/api/modules/react#useconvexauth) 훅과 [`Authenticated`](/api/modules/react#authenticated), [`Unauthenticated`](/api/modules/react#authenticated), [`AuthLoading`](/api/modules/react#authloading) 헬퍼 컴포넌트.

### 디버깅

[인증 디버깅](/auth/debug.mdx)을 참조하세요.

<StackPosts query="authentication" />
