---
title: "사용자 정의 JWT 공급자"
sidebar_label: "사용자 정의 JWT 공급자"
sidebar_position: 4
description:
  "전체 OIDC 프로토콜을 구현하지 않는 사용자 정의 JWT 공급자와 작동하도록 Convex를 구성합니다."
---

**참고: 이것은 고급 기능입니다!** [지원되는 타사 인증 공급자](/auth.mdx) 사용을 권장합니다.

[JWT](https://en.wikipedia.org/wiki/JSON_Web_Token)는 한 시간과 같은 제한된 기간 동안 사용자에 대한 클레임을 포함하는 세 개의 base64 인코딩된 JSON 객체를 결합한 문자열입니다. 사용자의 신원에 대한 증거(일반적으로 쿠키)를 받은 후 [jose](https://github.com/panva/jose)와 같은 라이브러리를 사용하여 생성하거나 [Clerk](https://clerk.com)과 같은 타사 인증 서비스에서 얻을 수 있습니다. JWT의 정보는 서명되어 있지만(Convex 배포는 정보가 실제로 발급자로부터 왔으며 수정되지 않았음을 알 수 있음) 일반적으로 암호화되지 않습니다(토큰을 base64 디코딩하거나 [jwt.io](https://jwt.io/)에 붙여넣어 읽을 수 있음).

인증 서비스가 사용자에게 발급한 JWT에 OpenID Connect (OIDC) 프로토콜을 구현하기 위한 올바른 필드가 포함되어 있는 경우, 이러한 JWT를 수락하도록 구성하는 가장 쉬운 방법은 `convex/auth.config.ts`에 [OIDC 공급자](/auth/advanced/custom-auth) 항목을 추가하는 것입니다. JWT를 발급하는 데 사용하는 인증 서비스나 라이브러리가 이러한 필드를 지원하지 않는 경우(예: [OpenAuth](https://openauth.js.org/) JWT는 OAuth 2.0 스펙을 구현하지만 OIDC는 구현하지 않기 때문에 `aud` 필드가 누락됨) `convex/auth.config.ts` 파일에서 사용자 정의 JWT 공급자를 구성해야 합니다.

사용자 정의 JWT는 헤더 필드 `kid`, `alg`, `typ`와 페이로드 필드 `sub`, `iss`, `exp`만 필요합니다. `iat` 필드도 토큰 갱신을 구현하기 위해 Convex 클라이언트에서 예상됩니다.

## 서버 측 통합

사용자 정의 JWT 인증 공급자를 구성하려면 `type: "customJwt"`를 사용하세요:

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      type: "customJwt",
      applicationID: "your-application-id",
      issuer: "https://your.issuer.url.com",
      jwks: "https://your.issuer.url.com/.well-known/jwks.json",
      algorithm: "RS256",
    },
  ],
};
```

- `applicationID`: Convex는 JWT가 `aud` 클레임에 이 값을 가지고 있는지 확인합니다. 이 필드를 생략하는 것에 대한 중요한 정보는 아래를 참조하세요. applicationID 필드는 필수가 아니지만 보안을 위해 많은 인증 공급자와 함께 사용하는 데 필요합니다. 생략하기 전에 아래를 자세히 읽어보세요.
- `issuer`: JWT의 발급자 URL입니다.
- `jwks`: 인증 공급자로부터 JWKS(JSON Web Key Set)를 가져오기 위한 URL입니다. 외부 서비스 호출을 피하고 싶다면 데이터 URI를 사용할 수 있습니다. 예: `"data:text/plain;charset=utf-8;base64,ey..."`
- `algorithm`: JWT 서명에 사용되는 알고리즘입니다. 현재 RS256과 ES256만 지원됩니다. 자세한 내용은 [RFC 7518](https://datatracker.ietf.org/doc/html/rfc7518#section-3.1)을 참조하세요.

`issuer` 속성은 사용된 JWT의 `iss` 필드와 정확히 일치해야 하며, 지정된 경우 `applicationID` 속성은 `aud` 필드와 정확히 일치해야 합니다. JWT가 일치하지 않으면 [jwt.io](https://jwt.io/)와 같은 도구를 사용하여 JWT를 보고 이러한 필드가 정확히 일치하는지 확인하세요.

### 경고: `applicationID`를 생략하는 것은 종종 안전하지 않습니다

인증 구성에서 `applicationID`를 생략하면 사용자 JWT의 `aud`(대상) 필드가 검증되지 않습니다. 많은 경우 이는 다른 서비스를 위한 JWT가 서비스에서 사용자를 위장하는 데 사용될 수 있기 때문에 안전하지 않습니다.

사용자가 `https://todos.com` 및 `https://banking.com` 두 서비스에 계정을 가지고 있고, 두 서비스 모두 동일한 타사 인증 서비스 `accounts.google.com`을 사용한다고 가정해 보겠습니다. todos.com에서 허용된 JWT는 todos.com 또는 해당 JWT에 액세스한 공격자에 의해 banking.com으로 인증하는 데 재사용될 수 있습니다.

JWT의 `aud`(대상) 필드가 이를 방지합니다: JWT가 `https://todos.com`의 특정 대상을 위해 생성된 경우 banking.com은 `aud` 필드를 강제하여 이를 받아들이지 않을 것을 알 수 있습니다.

사용자에게 발급된 JWT의 `iss`(발급자) URL이 애플리케이션에 특정하지 않은 `https://accounts.google.com`과 같은 경우, ApplicationID 없이 이러한 토큰을 신뢰하는 것은 악의적인 애플리케이션에 의해 JWT가 수집될 수 있기 때문에 안전하지 않습니다.

사용자에게 발급된 JWT가 `https://api.3rd-party-auth.com/client_0123...`와 같은 보다 구체적인 `iss` 필드를 가지고 있다면, 발급자 URL이 부여하는 모든 서비스를 제어하고 이러한 서비스 중 하나에 대한 액세스가 모든 서비스에 대한 액세스를 부여하도록 의도하는 경우 `aud` 필드 없이 사용하는 것이 안전할 수 있습니다.

### 사용자 정의 클레임

`subject`, `issuer`, `tokenIdentifier`와 같은 최상위 필드 외에도 JWT의 중첩된 필드의 하위 필드는 다음과 같이 구조화된 JWT에 대해 `authInfo["properties.id"]` 및 `authInfo["properties.favoriteColor"]`와 같이 `const authInfo = await ctx.auth.getUserIdentity()`에서 반환된 인증 데이터에서 액세스할 수 있습니다:

```json
{
  "properties": {
    "id": "123",
    "favoriteColor": "red"
  },
  "iss": "http://localhost:3000",
  "sub": "user:8fa2be73c2229e85",
  "exp": 1750968478
}
```

## 클라이언트 측 통합

사용자의 브라우저는 초기 JWT를 얻고 업데이트된 JWT를 요청하는 방법이 필요하며, 이전 JWT가 만료되기 전에 요청하는 것이 이상적입니다.

이를 수행하는 방법은 [사용자 정의 OIDC 공급자](/auth/advanced/custom-auth#client-side-integration)의 지침을 참조하세요.
