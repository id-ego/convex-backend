---
title: "Convex & WorkOS AuthKit"
sidebar_label: "WorkOS AuthKit"
sidebar_position: 20
description: "WorkOS AuthKit 인증을 Convex와 통합하기"
---

import UnderTheHood from "@site/docs/auth/_under_the_hood.mdx";
import ConfigTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainAuthKit.tsx";
import ConfigJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainAuthKit.jsx";
import Functions from "!!raw-loader!@site/../private-demos/snippets/convex/workosFunctions.ts";

[WorkOS AuthKit](https://authkit.com)은 비밀번호, 소셜 로그인 제공자, 이메일 일회용 코드, 2단계 인증 및 사용자 관리 기능을 사용한 로그인을 지원하는 인증 솔루션입니다.

## 시작하기

가장 빠르게 시작하는 방법은 Convex CLI를 통해 [연결된 WorkOS 계정](/docs/auth/authkit/auto-provision.mdx)을 생성하는 것입니다.

```bash
npm create convex@latest -- -t react-vite-authkit
cd my-app  # 또는 디렉토리에 지정한 이름
npm run dev
```

프롬프트를 따라 Convex 팀과 연결될 WorkOS 팀을 생성하세요. 이후 이 팀의 프로젝트에 대한 Convex 배포는 자체 WorkOS 환경을 자동으로 프로비저닝하고 구성할 수 있습니다.

그게 전부입니다! 이후 귀하와 Convex 팀의 다른 구성원은 [workos.com](https://workos.com)을 방문하지 않고도 개발 WorkOS 환경을 생성하고 구성할 수 있습니다.

### 기존 WorkOS 계정 구성하기

기존 WorkOS 계정으로 AuthKit을 사용하려면 계정을 구성하고 Convex 배포 및 로컬 `.env.local` 파일에 자격 증명을 복사해야 합니다.

<StepByStep>
  <Step title="WorkOS 가입하기">
    [workos.com/sign-up](https://signin.workos.com/sign-up)에서 무료 WorkOS 계정에 가입하세요.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-signup.png" alt="WorkOS 계정 가입하기" width={200} />
    </p>

  </Step>
  <Step title="AuthKit 설정하기">
    WorkOS 대시보드에서 **Authentication**, 그 다음 **AuthKit**으로 이동합니다. 여기서 **Set up
    AuthKit** 버튼을 클릭하여 계정에서 AuthKit을 활성화하세요.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-setup-authkit.png" alt="계정에서 AuthKit 설정하기" width={600} />
    </p>

  </Step>

  <Step title="AuthKit 설정 완료하기">
    **Use AuthKit's customizable hosted UI**가 선택된 상태로 **Begin setup** 버튼을 누르세요. 4단계 **Add default redirect endpoint URI**에 도달할 때까지 이러한 옵션을 원하는 대로 작성할 수 있습니다.

    Redirect URI는 로그인 후 WorkOS가 인증 코드를 반환할 엔드포인트입니다. 이는 애플리케이션의 도메인과 포트와 일치해야 하며, 라우트로 `/callback`을 사용해야 합니다. 예를 들어 애플리케이션이 `localhost:5173`에서 실행 중이면 여기의 값은 `http://localhost:5173/callback`이어야 합니다.

    AuthKit 설정을 완료하세요.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-redirect-uri.png" alt="리디렉트 URI 엔드포인트 설정하기" width={400} />
    </p>

  </Step>

  <Step title="Client ID와 API Key 복사하기">
    [get started](https://dashboard.workos.com/get-started) 페이지의 **Quick start** 섹션에서 `WORKOS_CLIENT_ID`를 찾아 복사하세요.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-client-id.png" alt="WorkOS Client ID 가져오기" width={400} />
    </p>

  </Step>
</StepByStep>

## 클라이언트 구성

Convex는 WorkOS AuthKit과의 통합을 위해 특별히 설계된 `<ConvexProviderWithAuthKit>` 제공자를 제공합니다. 이는 WorkOS의 [authkit-react](https://github.com/workos/authkit-react) SDK를 사용하여 작동합니다.

위의 WorkOS 설정을 완료했다면 아래에서 프레임워크를 선택하여 통합을 계속하세요.

사용 중인 WorkOS SDK에 대한 다음 섹션을 참조하세요:

- [React](#react) - SDK가 목록에 없는 경우 시작점으로 사용
- [Next.js](#nextjs)

### React

**예제:**
[React with Convex and AuthKit](https://github.com/workos/template-convex-react-vite-authkit)

이 가이드는 [AuthKit 설정](#configuring-an-existing-workos-account)을 완료했고 Convex가 통합된 React 앱이 있다고 가정합니다. 그렇지 않은 경우 먼저 [Convex React 빠른 시작](/quickstart/react.mdx)을 따르세요. 그런 다음:

<StepByStep>
  <Step title="WorkOS 대시보드에서 CORS 설정하기">

    [WorkOS 대시보드](https://dashboard.workos.com/environment/authentication/sessions)에서 "Cross-Origin Resource Sharing (CORS)" 아래의 **Manage**를 클릭하고 로컬 개발 도메인(예: Vite의 경우 `http://localhost:5173`)을 목록에 추가하세요. 배포할 때 프로덕션 도메인도 추가해야 합니다. 이렇게 하면 애플리케이션이 WorkOS AuthKit을 통해 사용자를 인증할 수 있습니다.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-cors-setup.png" alt="CORS 설정하기" width={400} />
    </p>

  </Step>

  <Step title="환경 변수 설정하기">
    `.env.local` 파일에 `WORKOS_CLIENT_ID` 및 `WORKOS_REDIRECT_URI` 환경 변수를 추가하세요. Vite를 사용하는 경우 `VITE_` 접두사를 붙여야 합니다.

    **참고:** 이러한 값은 [WorkOS 대시보드](https://dashboard.workos.com/)에서 찾을 수 있습니다.

    ```env title=".env.local"
    # WorkOS AuthKit 구성
    VITE_WORKOS_CLIENT_ID=your-workos-client-id-here
    VITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
    ```

  </Step>
  <Step title="WorkOS Client ID로 Convex 구성하기">
    앱의 `convex` 폴더에 다음 코드로 새 파일 <JSDialectFileName name="auth.config.ts" />를 만드세요. 이것은 액세스 토큰 검증을 위한 서버 측 구성입니다.

    ```ts title="convex/auth.config.ts"
    const clientId = process.env.WORKOS_CLIENT_ID;

    const authConfig = {
      providers: [
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/`,
          algorithm: 'RS256',
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
      applicationID: clientId,
        },
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/user_management/${clientId}`,
          algorithm: 'RS256',
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
          applicationID: clientId,
        },
      ],
    };

    export default authConfig;
    ```

  </Step>
  <Step title="변경 사항 배포하기">
    `npx convex dev`를 실행하여 구성을 백엔드에 자동으로 동기화하세요.

    오류와 Convex 배포에서 WORKOS_CLIENT_ID 환경 변수를 입력하기 위해 클릭할 링크가 표시됩니다. 링크를 따라 WorkOS 클라이언트 ID를 붙여넣고 저장하면 `npx convex dev` 명령이 "Convex functions ready"를 표시하는 것을 볼 수 있습니다.

    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="AuthKit 설치하기">
    새 터미널 창에서 AuthKit React SDK를 설치하세요:

    ```sh
    npm install @workos-inc/authkit-react @convex-dev/workos
    ```

  </Step>

  <Step title="ConvexProviderWithAuthKit 구성하기">
    AuthKit과 Convex 모두 앱에 인증 및 클라이언트 컨텍스트를 제공하는 제공자 컴포넌트가 있습니다.

    이미 앱을 `<ConvexProvider>`로 래핑했어야 합니다. 이를 `<ConvexProviderWithAuthKit>`로 교체하고 WorkOS의 `useAuth()` 훅을 전달하세요.

    그런 다음 `<AuthKitProvider>`로 래핑하세요. `<AuthKitProvider>`는 `clientId` 및 `redirectUri` prop이 필요하며, 각각 `VITE_WORKOS_CLIENT_ID` 및 `VITE_WORKOS_REDIRECT_URI`로 설정할 수 있습니다.


    <TSAndJSSnippet
      title="src/main.tsx"
      sourceTS={ConfigTS}
      sourceJS={ConfigJS}
      highlightPatterns={["AuthKitProvider", "clientId", "redirectUri", "ConvexProviderWithAuthKit"]}
    />

  </Step>

  <Step title="인증 상태에 따라 UI 표시하기">
    사용자가 로그인했거나 로그아웃했을 때 표시할 UI를 Convex의 `<Authenticated>`, `<Unauthenticated>` 및 `<AuthLoading>` 헬퍼 컴포넌트를 사용하여 제어할 수 있습니다.

    사용자가 로그인했는지 확인해야 할 때는 AuthKit의 `useAuth()` 훅 대신 [`useConvexAuth()`](/api/modules/react#useconvexauth) 훅을 사용하는 것이 중요합니다. `useConvexAuth()` 훅은 브라우저가 Convex 백엔드에 인증된 요청을 하는 데 필요한 인증 토큰을 가져왔는지, 그리고 Convex 백엔드가 이를 검증했는지 확인합니다.

    다음 예제에서 `<Content />` 컴포넌트는 `<Authenticated>`의 자식이므로, 그 내용과 모든 자식 컴포넌트는 인증된 사용자를 보장받으며, Convex 쿼리는 인증을 요구할 수 있습니다.

    ```tsx title="src/App.tsx"
    import { Authenticated, Unauthenticated, useQuery } from 'convex/react';
    import { api } from '../convex/_generated/api';
    import { useAuth } from '@workos-inc/authkit-react';

    export default function App() {
      const { user, signIn, signOut } = useAuth();

      return (
        <div className="p-4"> <div className="flex justify-between items-center mb-4">
            <h1>Convex + AuthKit</h1>
            <button onClick={() => (user ? signOut() : void signIn())}>{user ? 'Sign out' : 'Sign in'}</button>
          </div>
          <Authenticated>
            <Content />
          </Authenticated>
          <Unauthenticated>
            <p>Please sign in to view data</p>
          </Unauthenticated>
        </div>
      );
    }

    function Content() {
      const data = useQuery(api.myFunctions.listNumbers, { count: 10 });

      if (!data) return <p>Loading...</p>;

      return (
        <div>
          <p>Welcome {data.viewer}!</p>
          <p>Numbers: {data.numbers?.join(', ') || 'None'}</p>
        </div>
      );
    }
    ```

  </Step>

  <Step title="Convex 함수에서 인증 상태 사용하기">
    클라이언트가 인증되면 `ctx.auth.getUserIdentity`를 통해 JWT에 저장된 정보에 접근할 수 있습니다.

    클라이언트가 인증되지 않았다면 `ctx.auth.getUserIdentity`는 `null`을 반환합니다.

    **이 쿼리를 호출하는 컴포넌트가 `convex/react`의 `<Authenticated>`의 자식인지 확인하세요**. 그렇지 않으면 페이지 로드 시 오류가 발생합니다.

    <TSAndJSSnippet
      title="convex/myFunctions.ts"
      sourceTS={Functions}
      sourceJS={Functions}
    />

  </Step>
</StepByStep>

**참고:**
[React 템플릿 저장소](https://github.com/workos/template-convex-react-vite-authkit)에는 완전한 작동 애플리케이션을 위한 추가 기능이 포함되어 있습니다. 이 튜토리얼은 핵심 통합 단계를 다루지만, 템플릿은 더 포괄적인 구현을 제공합니다.

### Next.js

**예제:**
[Next.js with Convex and AuthKit](https://github.com/workos/template-convex-nextjs-authkit)

이 가이드는 [AuthKit 설정](#configuring-an-existing-workos-account)을 완료했고 Convex가 통합된 Next.js 앱이 있다고 가정합니다. 그렇지 않은 경우 먼저 [Convex Next.js 빠른 시작](/quickstart/nextjs.mdx)을 따르세요. 그런 다음:

<StepByStep>
  <Step title="환경 변수 설정하기">
    `.env.local` 파일에 다음 환경 변수를 추가하세요:

    ```env title=".env.local"
    # WorkOS AuthKit 구성
    WORKOS_CLIENT_ID=client_your_client_id_here
    WORKOS_API_KEY=sk_test_your_api_key_here
    WORKOS_COOKIE_PASSWORD=your_secure_password_here_must_be_at_least_32_characters_long
    NEXT_PUBLIC_WORKOS_REDIRECT_URI=http://localhost:3000/callback

    # Convex 구성 (작성할 필요 없음, Convex에서 생성됨)
    # `npx convex dev`에서 사용하는 배포
    CONVEX_DEPLOY_KEY=your_convex_deploy_key_here
    NEXT_PUBLIC_CONVEX_URL=https://your-convex-url.convex.cloud
    ```

  </Step>
  <Step title="WorkOS Client ID로 Convex 구성하기">
    앱의 `convex` 폴더에 다음 코드로 새 파일 <JSDialectFileName name="auth.config.ts" />를 만드세요. 이것은 액세스 토큰 검증을 위한 서버 측 구성입니다.

    ```ts title="convex/auth.config.ts"
    const clientId = process.env.WORKOS_CLIENT_ID;

    const authConfig = {
      providers: [
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/`,
          algorithm: 'RS256',
          applicationID: clientId,
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
        },
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/user_management/${clientId}`,
          algorithm: 'RS256',
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
          applicationID: clientId,
        },
      ],
    };

    export default authConfig;
    ```

  </Step>
  <Step title="변경 사항 배포하기">
    `npx convex dev`를 실행하여 구성을 백엔드에 자동으로 동기화하세요.

    오류와 Convex 배포에서 WORKOS_CLIENT_ID 환경 변수를 입력하기 위해 클릭할 링크가 표시됩니다. 링크를 따라 WorkOS 클라이언트 ID를 붙여넣고 저장하면 `npx convex dev` 명령이 "Convex functions ready"를 표시하는 것을 볼 수 있습니다.

    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="AuthKit 설치하기">
    새 터미널 창에서 AuthKit Next.js SDK를 설치하세요:

    ```sh
    npm install @workos-inc/authkit-nextjs @convex-dev/workos
    ```

  </Step>

  <Step title="AuthKit 미들웨어 추가하기">
    AuthKit의 `authkitMiddleware()` 헬퍼는 앱 전체에서 사용자 인증 상태에 접근할 수 있게 합니다.

    `middleware.ts` 파일을 만드세요.

    `middleware.ts` 파일에서 `authkitMiddleware()` 헬퍼를 내보내세요:

    ```tsx {{ filename: 'middleware.ts' }}
    import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

    export default authkitMiddleware({
      middlewareAuth: {
        enabled: true,
        unauthenticatedPaths: ['/', '/sign-in', '/sign-up'],
      },
    });

    export const config = {
      matcher: [
        // Next.js 내부 및 모든 정적 파일 제외, 검색 매개변수에서 발견되지 않는 한
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // API 라우트에 대해 항상 실행
        '/(api|trpc)(.*)',
      ],
    };
    ```

  </Step>

  <Step title="인증 라우트 추가하기">
    로그인, 가입 및 콜백 플로우를 처리하기 위해 WorkOS AuthKit에 필요한 인증 라우트를 생성하세요.

    이러한 라우트는 사용자가 로그인, 가입 및 인증 후 돌아올 수 있는 엔드포인트를 제공하여 인증 플로우를 가능하게 합니다.

    **OAuth 콜백을 처리하기 위한 콜백 라우트 생성:**

    ```tsx title="app/callback/route.ts"
    import { handleAuth } from '@workos-inc/authkit-nextjs';

    export const GET = handleAuth();
    ```

  </Step>

  <Step title="로그인 라우트 생성하기">

    ```tsx title="app/sign-in/route.ts"
    import { redirect } from 'next/navigation';
    import { getSignInUrl } from '@workos-inc/authkit-nextjs';

    export async function GET() {
      const authorizationUrl = await getSignInUrl();
      return redirect(authorizationUrl);
    }
    ```

  </Step>

  <Step title="가입 라우트 생성하기">
    사용자를 WorkOS 가입으로 리디렉션하려면:

    ```tsx title="app/sign-up/route.ts"
    import { redirect } from 'next/navigation';
    import { getSignUpUrl } from '@workos-inc/authkit-nextjs';

    export async function GET() {
      const authorizationUrl = await getSignUpUrl();
      return redirect(authorizationUrl);
    }
    ```

  </Step>

  <Step title="ConvexProviderWithAuthKit 구성하기">
    Next.js 앱은 실시간 데이터를 위해 AuthKit 인증과 Convex를 연결해야 합니다. 두 가지를 모두 처리하는 단일 제공자 컴포넌트를 만들겠습니다.

    **제공자 컴포넌트 생성하기**

    이 단일 컴포넌트는 다음을 처리합니다:

    - WorkOS 인증 설정
    - Convex 클라이언트 초기화
    - WorkOS와 Convex 간의 토큰 관리
    - 로딩 상태 및 오류 처리

    `components/ConvexClientProvider.tsx` 생성:

    ```tsx title="components/ConvexClientProvider.tsx"
    'use client';

    import { ReactNode, useCallback, useRef } from 'react';
    import { ConvexReactClient } from 'convex/react';
    import { ConvexProviderWithAuth } from 'convex/react';
    import { AuthKitProvider, useAuth, useAccessToken } from '@workos-inc/authkit-nextjs/components';

    const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

    export function ConvexClientProvider({ children }: { children: ReactNode }) {
      return (
        <AuthKitProvider>
          <ConvexProviderWithAuth client={convex} useAuth={useAuthFromAuthKit}>
            {children}
          </ConvexProviderWithAuth>
        </AuthKitProvider>
      );
    }

    function useAuthFromAuthKit() {
      const { user, loading: isLoading } = useAuth();
      const { accessToken, loading: tokenLoading, error: tokenError } = useAccessToken();
      const loading = (isLoading ?? false) || (tokenLoading ?? false);
      const authenticated = !!user && !!accessToken && !loading;

      const stableAccessToken = useRef<string | null>(null);
      if (accessToken && !tokenError) {
        stableAccessToken.current = accessToken;
      }

      const fetchAccessToken = useCallback(async () => {
        if (stableAccessToken.current && !tokenError) {
          return stableAccessToken.current;
        }
        return null;
      }, [tokenError]);

      return {
        isLoading: loading,
        isAuthenticated: authenticated,
        fetchAccessToken,
      };
    }
    ```

  </Step>

  <Step title="레이아웃에 추가하기">

    `app/layout.tsx`를 업데이트하여 제공자를 사용하세요:

    ```tsx title="app/layout.tsx"
    import type { Metadata } from 'next';
    import { Geist, Geist_Mono } from 'next/font/google';
    import './globals.css';
    import { ConvexClientProvider } from '@/components/ConvexClientProvider';

    const geistSans = Geist({
      variable: '--font-geist-sans',
      subsets: ['latin'],
    });

    const geistMono = Geist_Mono({
      variable: '--font-geist-mono',
      subsets: ['latin'],
    });

    export const metadata: Metadata = {
      title: 'Create Next App',
      description: 'Generated by create next app',
      icons: {
        icon: '/convex.svg',
      },
    };

    export default function RootLayout({
      children,
    }: Readonly<{
      children: React.ReactNode;
    }>) {
      return (
        <html lang="en">
          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
            <ConvexClientProvider>{children}</ConvexClientProvider>
          </body>
        </html>
      );
    }
    ```

  </Step>

  <Step title="인증 상태에 따라 UI 표시하기">
      사용자가 로그인했거나 로그아웃했을 때 표시할 UI를 Convex의 `<Authenticated>`, `<Unauthenticated>` 및 `<AuthLoading>` 헬퍼 컴포넌트를 사용하여 제어할 수 있습니다. 이들은 WorkOS AuthKit의 `useAuth()` 로딩 상태 및 수동 인증 확인 대신 사용해야 합니다.

      사용자가 로그인했는지 확인해야 할 때는 WorkOS AuthKit의 `useAuth()` 훅 대신 [`useConvexAuth()`](/api/modules/react#useconvexauth) 훅을 사용하는 것이 중요합니다. `useConvexAuth()` 훅은 브라우저가 Convex 백엔드에 인증된 요청을 하는 데 필요한 인증 토큰을 가져왔는지, 그리고 Convex 백엔드가 이를 검증했는지 확인합니다.

      다음 예제에서 `<Content />` 컴포넌트는 `<Authenticated>`의 자식이므로, 그 내용과 모든 자식 컴포넌트는 인증된 사용자를 보장받으며, Convex 쿼리는 인증을 요구할 수 있습니다.

      ```tsx title="app/page.tsx"
      "use client";

      import { Authenticated, Unauthenticated, useQuery } from "convex/react";
      import { useAuth } from "@workos-inc/authkit-nextjs/components";
      import { api } from "../convex/_generated/api";
      import Link from "next/link";

      export default function Home() {
        const { user, signOut } = useAuth();

        return (
          <div className="p-4">
            <div className="flex justify-between items-center mb-4">
              <h1>Convex + AuthKit</h1>
              <div className="flex gap-2">
                {user ? (
                  <button onClick={() => signOut()}>Sign out</button>
                ) : (
                  <>
                    <Link href="/sign-in">
                      <button>Sign in</button>
                    </Link>
                    <Link href="/sign-up">
                      <button>Sign up</button>
                    </Link>
                  </>
                )}
              </div>
            </div>
            <Authenticated>
              <Content />
            </Authenticated>
            <Unauthenticated>
              <p>Please sign in to view data</p>
            </Unauthenticated>
          </div>
        );
      }

      function Content() {
        const data = useQuery(api.myFunctions.listNumbers, { count: 10 });

        if (!data) return <p>Loading...</p>;

        return (
          <div>
            <p>Welcome {data.viewer}!</p>
            <p>Numbers: {data.numbers?.join(', ') || 'None'}</p>
          </div>
        );
      }
      ```
    </Step>

  <Step title="Convex 함수에서 인증 상태 사용하기">
    클라이언트가 인증되면 `ctx.auth.getUserIdentity`를 통해 JWT에 저장된 정보에 접근할 수 있습니다.

    클라이언트가 인증되지 않았다면 `ctx.auth.getUserIdentity`는 `null`을 반환합니다.

    **이 쿼리를 호출하는 컴포넌트가 `convex/react`의 `<Authenticated>`의 자식인지 확인하세요**. 그렇지 않으면 페이지 로드 시 오류가 발생합니다.

    <TSAndJSSnippet
      title="convex/myFunctions.ts"
      sourceTS={Functions}
      sourceJS={Functions}
    />

  </Step>
</StepByStep>

**참고:**
[Next.js 템플릿 저장소](https://github.com/workos/template-convex-nextjs-authkit)에는 완전한 작동 애플리케이션을 위한 추가 기능이 포함되어 있습니다. 이 튜토리얼은 핵심 통합 단계를 다루지만, 템플릿은 더 포괄적인 구현을 제공합니다.

## 다음 단계

### 함수에서 사용자 정보 접근하기

쿼리, 뮤테이션 및 액션에서 인증된 사용자에 대한 정보에 접근하는 방법을 알아보려면 [함수의 인증](/auth/functions-auth.mdx)을 참조하세요.

Convex 데이터베이스에 사용자 정보를 저장하는 방법을 알아보려면 [Convex 데이터베이스에 사용자 저장하기](/auth/database-auth.mdx)를 참조하세요.

### 클라이언트 측에서 사용자 정보 접근하기

인증된 사용자의 정보에 접근하려면 AuthKit의 [`useAuth()`](https://github.com/workos/authkit-react?tab=readme-ov-file#useauth) 훅을 사용하여 접근할 수 있는 AuthKit의 `User` 객체를 사용하세요. `User` 객체에 대한 자세한 내용은 [WorkOS 문서](https://workos.com/docs/reference/user-management/user)를 참조하세요.

```tsx title="components/Badge.tsx"
export default function Badge() {
  const { user } = useAuth();

  return <span>Logged in as {user.firstName}</span>;
}
```

## 개발 및 프로덕션 인스턴스 구성하기

Convex 개발 및 프로덕션 배포 간에 다른 AuthKit 인스턴스를 구성하려면 Convex 대시보드에서 구성된 환경 변수를 사용할 수 있습니다.

### 백엔드 구성하기

WorkOS 대시보드에서 [**API keys**](https://dashboard.workos.com/api-keys) 페이지로 이동합니다. WorkOS Client ID를 복사하세요. 이 Client ID는 Convex가 WorkOS AuthKit의 액세스 토큰을 검증하는 데 필요합니다. 개발 환경에서는 `client_01XXXXXXXXXXXXXXXXXXXXXXXX` 형식입니다. 프로덕션에서는 동일한 형식을 따르지만 프로덕션 WorkOS 애플리케이션을 나타냅니다.

WorkOS Client ID를 `.env` 파일에 붙여넣고 `WORKOS_CLIENT_ID` 환경 변수로 설정하세요. 이 환경 변수는 서버 측에서 사용되므로 `NEXT_PUBLIC_` 접두사가 필요하지 않습니다.

```env title=".env"
WORKOS_CLIENT_ID=client_01XXXXXXXXXXXXXXXXXXXXXXXX
```

그런 다음 `convex/auth.config.ts` 파일을 업데이트하여 환경 변수를 사용하세요:

```ts title="convex/auth.config.ts"
const clientId = process.env.WORKOS_CLIENT_ID;

export default {
  providers: [
    {
      type: "customJwt",
      issuer: `https://api.workos.com/`,
      algorithm: "RS256",
      applicationID: clientId,
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
    },
    {
      type: "customJwt",
      issuer: `https://api.workos.com/user_management/${clientId}`,
      algorithm: "RS256",
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
      applicationID: clientId,
    },
  ],
};
```

**개발 구성**

Convex [대시보드](https://dashboard.convex.dev)의 왼쪽 사이드바에서 개발 배포로 전환하고 `WORKOS_CLIENT_ID` 환경 변수를 개발 WorkOS Client ID로 설정하세요.

그런 다음 배포를 새 구성으로 전환하려면 `npx convex dev`를 실행하세요.

**프로덕션 구성**

Convex [대시보드](https://dashboard.convex.dev)의 왼쪽 사이드바에서 프로덕션 배포로 전환하고 `WORKOS_CLIENT_ID` 환경 변수를 프로덕션 WorkOS Client ID로 설정하세요.

그런 다음 배포를 새 구성으로 전환하려면 `npx convex deploy`를 실행하세요.

### WorkOS AuthKit의 API 키 구성하기

WorkOS AuthKit의 API 키는 개발 또는 프로덕션용인지에 따라 다릅니다. `.env` 파일과 Vercel 또는 Netlify와 같은 호스팅 플랫폼의 환경 변수도 업데이트하는 것을 잊지 마세요.

**개발 구성**

개발용 WorkOS API Key는 `sk_test_...` 형식을 따릅니다. 개발용 WorkOS Client ID는 `client_01...` 형식을 따릅니다.

```env title=".env.local"
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_test_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="http://localhost:3000/callback"
```

**프로덕션 구성**

프로덕션용 WorkOS API Key는 `sk_live_...` 형식을 따릅니다. 프로덕션용 WorkOS Client ID는 `client_01...` 형식을 따릅니다.

```env title=".env"
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_live_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="https://your-domain.com/callback"
```

### 추가 WorkOS AuthKit 구성

WorkOS AuthKit에는 추가 구성이 필요합니다:

**Cookie Password**: 세션 쿠키를 암호화하는 데 사용되는 안전한 비밀번호입니다. 최소 32자 이상이어야 합니다. `openssl rand -base64 24`로 무작위 비밀번호를 생성할 수 있습니다.

**Redirect URI**: 인증 후 사용자가 리디렉션되는 URL입니다. 환경 변수와 WorkOS 대시보드 애플리케이션 설정 모두에서 구성되어야 합니다.

## 인증 디버깅하기

사용자가 WorkOS AuthKit 로그인 플로우를 성공적으로 완료했지만 페이지로 리디렉션된 후 `useConvexAuth()`가 `isAuthenticated: false`를 반환하는 경우, 백엔드가 올바르게 구성되지 않았을 수 있습니다.

`convex/auth.config.ts` 파일에는 구성된 인증 제공자 목록이 포함되어 있습니다. 새 제공자를 추가한 후 `npx convex dev` 또는 `npx convex deploy`를 실행하여 구성을 백엔드에 동기화해야 합니다.

WorkOS AuthKit 통합의 일반적인 문제:

1. **잘못된 Client ID**: Convex 환경의 `WORKOS_CLIENT_ID`가 WorkOS 애플리케이션과 일치하는지 확인하세요
2. **누락된 환경 변수**: 필요한 모든 WorkOS 환경 변수가 로컬 환경과 Convex 대시보드 모두에 설정되어 있는지 확인하세요
3. **Redirect URI 불일치**: `NEXT_PUBLIC_WORKOS_REDIRECT_URI`가 WorkOS 대시보드에 구성된 것과 일치하는지 확인하세요
4. **누락된 `aud` 클레임**: WorkOS JWT는 기본적으로 Convex가 토큰 검증에 필요한 `aud`(대상) 클레임을 포함하지 않을 수 있습니다. WorkOS 대시보드 JWT 구성을 확인하여 대상 클레임이 Client ID로 올바르게 설정되어 있는지 확인하세요

더 자세한 디버깅 단계는 WorkOS AuthKit 문서 또는 [인증 디버깅](/auth/debug.mdx)을 참조하세요.

## 내부 작동 방식

<UnderTheHood
  provider="AuthKit"
  integrationProvider={<code>ConvexProviderWithAuthKit</code>}
  providerProvider={<code>AuthKitProvider</code>}
  configProp={
    <>
      the{" "}
      <a
        href="https://workos.com/docs/user-management/vanilla/nodejs/1-configure-your-project/configure-a-redirect-uri"
        target="_blank"
      >
        <code>redirectUri</code>
      </a>{" "}
      prop
    </>
  }
/>
