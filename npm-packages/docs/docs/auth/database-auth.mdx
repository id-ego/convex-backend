---
title: "Convex 데이터베이스에 사용자 저장하기"
sidebar_label: "데이터베이스"
sidebar_position: 120
description: "Convex 데이터베이스에 사용자 정보 저장하기"
---

import Schema from "!!raw-loader!@site/../demos/users-and-clerk/convex/schema.ts";
import useStoreUserEffectTS from "!!raw-loader!@site/../demos/users-and-clerk/src/useStoreUserEffect.ts";
import useStoreUserEffectJS from "!!raw-loader!@site/../private-demos/snippets/users-and-clerk/useStoreUserEffect.js";
import MessagesTS from "!!raw-loader!@site/../demos/users-and-clerk/convex/messages.ts";
import UsersTS from "!!raw-loader!@site/../demos/users-and-clerk/convex/users.ts";
import App from "!!raw-loader!@site/../private-demos/snippets/src/clerkStoreUserApp.tsx";
import WebhooksSchema from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/schema.ts";
import WebhookMutations from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/users.ts";
import WebhookEndpoint from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/http.ts";
import WebhookMessages from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/messages.ts";
import WebhookHook from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/src/useCurrentUser.ts";
import WebhookClient from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/src/App.tsx";

_[Convex Auth](/auth/convex-auth.mdx)를 사용하는 경우 사용자 정보가 이미 데이터베이스에 저장되어 있습니다. 별도로 구현할 필요가 없습니다._

다음과 같은 이유로 사용자 정보를 Convex 데이터베이스에 직접 저장하고 싶을 수 있습니다:

- 함수가 현재 로그인한 사용자뿐만 아니라 다른 사용자에 대한 정보도 필요한 경우
- 함수가 [Open ID Connect JWT](/auth/functions-auth.mdx)에서 제공되는 필드 외의 정보에 접근해야 하는 경우

데이터베이스에 사용자 정보를 저장하는 두 가지 방법 중 하나를 선택할 수 있습니다(하지만 두 번째 방법만 JWT에 포함되지 않은 정보를 저장할 수 있습니다):

1. 앱의 [클라이언트에서 뮤테이션 호출](#call-a-mutation-from-the-client)하여 [`ctx.auth`](/api/interfaces/server.Auth)에서 사용할 수 있는 JWT의 정보를 저장합니다
2. [웹훅을 구현](#set-up-webhooks)하여 사용자 정보가 변경될 때마다 인증 제공자가 호출하도록 합니다

## 클라이언트에서 뮤테이션 호출하기

**예제:**
[Convex Authentication with Clerk](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk)

### (선택사항) 사용자 테이블 스키마

`"users"` 테이블을 정의할 수 있으며, 선택적으로 데이터베이스에서 사용자를 효율적으로 조회하기 위한 [인덱스](/database/reading-data/indexes/indexes.md)를 추가할 수 있습니다.

아래 예제에서는 `ctx.auth.getUserIdentity()`의 `tokenIdentifier`를 사용하여 사용자를 식별하지만, `subject` 필드(일반적으로 인증 제공자의 고유 사용자 ID로 설정됨)나 `email`을 사용할 수도 있습니다. 단, 인증 제공자가 이메일 인증을 제공하고 활성화한 경우에만 가능합니다.

어떤 필드를 사용하느냐에 따라 여러 제공자가 상호 작용하는 방식과 다른 제공자로 마이그레이션하는 난이도가 결정됩니다.

<Snippet source={Schema} snippet="user" title="convex/schema.ts" />

### 현재 사용자 저장을 위한 뮤테이션

다음은 사용자의 `name`과 `tokenIdentifier`를 저장하는 뮤테이션의 예시입니다:

<TSAndJSSnippet sourceTS={UsersTS} sourceJS={UsersTS} title="convex/users.js" />

### React에서 사용자 저장 뮤테이션 호출하기

사용자가 로그인할 때 `useEffect` 훅에서 이 뮤테이션을 호출할 수 있습니다. 뮤테이션이 성공하면 로컬 상태를 업데이트하여 사용자가 저장되었음을 반영할 수 있습니다.

이 작업을 수행하는 헬퍼 훅:

<TSAndJSSnippet
  sourceTS={useStoreUserEffectTS}
  sourceJS={useStoreUserEffectJS}
  title="src/useStoreUserEffect.ts"
/>

이 훅을 최상위 컴포넌트에서 사용할 수 있습니다. 쿼리가 사용자 문서가 존재해야 하는 경우, 사용자가 저장된 후에만 해당 쿼리를 호출하는 컴포넌트를 렌더링해야 합니다:

<TSAndJSSnippet sourceTS={App} sourceJS={App} title="src/App.tsx" />

이 방법으로 `useStoreUserEffect` 훅이 `useConvexAuth` 훅을 대체합니다.

### 현재 사용자의 문서 ID 사용하기

사용자 저장 뮤테이션과 유사하게 현재 사용자의 ID를 가져오거나, 사용자가 저장되지 않은 경우 오류를 발생시킬 수 있습니다.

이제 사용자가 Convex 데이터베이스에 문서로 저장되었으므로, 다른 문서에서 외래 키로 사용자 ID를 사용할 수 있습니다:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="load-user"
  title="convex/messages.ts"
  suffix={`    // do something with \`user\`...
  }
});`}
/>

### ID로 사용자 로드하기

다른 사용자에 대한 정보는 ID를 통해 가져올 수 있습니다:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="use-users"
  title="convex/messages.ts"
  prefix={`import { query } from "./_generated/server";
`}
/>

## 웹훅 설정하기

이 가이드는 Clerk을 사용하지만, [Auth0 Actions](https://auth0.com/docs/customize/actions/actions-overview)를 통해 Auth0도 유사하게 설정할 수 있습니다.

이 구현에서는 사용자가 가입하거나 계정을 업데이트하거나 삭제할 때마다 Clerk이 HTTP 엔드포인트를 통해 Convex 백엔드를 호출합니다.

**예제:**
[Convex Authentication with Clerk and Webhooks](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk-webhooks)

### Clerk에서 웹훅 엔드포인트 구성하기

Clerk 대시보드에서 _Webhooks_로 이동하여 _+ Add Endpoint_를 클릭합니다.

_Endpoint URL_을 `https://<your deployment name>.convex.site/clerk-users-webhook`로 설정합니다(도메인이 **`.site`**로 끝나며, `.cloud`가 아님에 주의). 프로젝트 디렉토리의 `.env.local` 파일이나 Convex 대시보드의 [Deployment URL](/dashboard/deployments/settings.md)에서 배포 이름을 확인할 수 있습니다. 예를 들어, 엔드포인트 URL은 다음과 같을 수 있습니다:
`https://happy-horse-123.convex.site/clerk-users-webhook`.

_Message Filtering_에서 모든 사용자 이벤트에 대해 **user**를 선택합니다(스크롤하거나 검색 입력 사용).

_Create_를 클릭합니다.

엔드포인트가 저장된 후 _Signing Secret_(UI 오른쪽)을 복사합니다. `whsec_`로 시작해야 합니다. Convex [대시보드](https://dashboard.convex.dev)에서 `CLERK_WEBHOOK_SECRET` 환경 변수의 값으로 설정합니다.

### (선택사항) 사용자 테이블 스키마

`"users"` 테이블을 정의할 수 있으며, 선택적으로 데이터베이스에서 사용자를 효율적으로 조회하기 위한 [인덱스](/database/reading-data/indexes/indexes.md)를 추가할 수 있습니다.

아래 예제에서는 `ctx.auth.getUserIdentity()`의 `subject`를 사용하여 사용자를 식별하며, 이는 Clerk 사용자 ID로 설정되어야 합니다.

<Snippet source={WebhooksSchema} snippet="table" title="convex/schema.ts" />

### 사용자 업서트 및 삭제를 위한 뮤테이션

다음은 웹훅을 통해 수신된 업데이트를 처리하는 뮤테이션의 예시입니다:

<TSAndJSSnippet
  sourceTS={WebhookMutations}
  sourceJS={WebhookMutations}
  title="convex/users.ts"
/>

이 파일에는 몇 가지 헬퍼도 포함되어 있습니다:

- `current`는 사용자 정보를 클라이언트에 노출하여, 클라이언트가 웹훅이 이미 성공했는지 판단하는 데 도움을 줍니다
- `upsertFromClerk`는 사용자가 가입하거나 계정을 업데이트할 때 호출됩니다
- `deleteFromClerk`는 사용자가 앱에서 Clerk UI를 통해 계정을 삭제할 때 호출됩니다
- `getCurrentUserOrThrow`는 현재 로그인한 사용자를 가져오거나 오류를 발생시킵니다
- `getCurrentUser`는 현재 로그인한 사용자를 가져오거나 null을 반환합니다
- `userByExternalId`는 Clerk ID를 기반으로 사용자를 가져오며, 현재 사용자를 가져오거나 웹훅을 통해 기존 사용자를 업데이트할 때만 사용됩니다

### 웹훅 엔드포인트 구현

실제 HTTP 엔드포인트를 구현하는 방법은 다음과 같습니다:

<TSAndJSSnippet
  sourceTS={WebhookEndpoint}
  sourceJS={WebhookEndpoint}
  title="convex/http.ts"
/>

지금 코드를 배포하고 로그인하면 Convex 데이터베이스에 사용자가 생성되는 것을 볼 수 있습니다.

### 현재 사용자의 문서 사용하기

이전에 정의한 헬퍼를 사용하여 현재 사용자의 문서를 가져올 수 있습니다.

이제 사용자가 Convex 데이터베이스에 문서로 저장되었으므로, 다른 문서에서 외래 키로 사용자 ID를 사용할 수 있습니다:

<TSAndJSSnippet
  sourceTS={WebhookMessages}
  sourceJS={WebhookMessages}
  snippet="current-user"
  title="convex/messages.ts"
/>

### ID로 사용자 로드하기

다른 사용자에 대한 정보는 ID를 통해 가져올 수 있습니다:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="use-users"
  title="convex/messages.ts"
/>

### 현재 사용자가 저장될 때까지 대기하기

쿼리에서 현재 사용자의 문서를 사용하려면 사용자가 이미 저장되었는지 확인해야 합니다. 쿼리를 호출하는 컴포넌트를 렌더링하기 전이나 앱의 인증된 부분으로 리디렉션하기 전에 이 조건을 명시적으로 확인할 수 있습니다.

예를 들어, 현재 사용자가 저장되었는지 여부를 고려하여 클라이언트의 현재 인증 상태를 판단하는 훅을 정의할 수 있습니다:

<TSAndJSSnippet
  sourceTS={WebhookHook}
  sourceJS={WebhookHook}
  title="src/useCurrentUser.ts"
/>

그런 다음 적절한 컴포넌트를 렌더링하는 데 사용할 수 있습니다:

<TSAndJSSnippet
  sourceTS={WebhookClient}
  sourceJS={WebhookClient}
  snippet="client-blocking"
  title="src/App.tsx"
/>
