---
title: "Next.js 서버 렌더링"
sidebar_label: "서버 렌더링"
sidebar_position: 10
description:
  "preloadQuery, fetchQuery 및 서버 액션을 사용하여 Next.js App Router에서 Convex로 서버 측 렌더링을 구현하여 성능을 개선하세요."
---

import PreloadQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/TasksWrapper.tsx";
import AuthedPreloadQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/AuthedTasksWrapper.tsx";
import UsePreloadedQueryTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/Tasks.tsx";
import UsePreloadedQueryJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/TasksJS.jsx";
import FetchQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/StaticTasks.tsx";
import ServerActionTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/example/page.tsx";
import ServerActionJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/exampleJS/page.jsx";
import RouteHandlerTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/api/route.ts";
import RouteHandlerJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/apiJS/route.js";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Next.js는 초기 페이지 로드 중 서버에서 클라이언트 컴포넌트와 서버 컴포넌트를 모두 자동으로 렌더링합니다.

기본적으로 클라이언트 컴포넌트는 Convex 데이터가 로드될 때까지 기다리지 않으며 UI는 "로딩" 상태로 렌더링됩니다. 서버 렌더링 중 데이터를 미리 로드하는 방법과 Next.js 서버 측에서 Convex 배포와 상호작용하는 방법을 알아보려면 계속 읽어보세요.

**예제:**
[Next.js App Router](https://github.com/get-convex/convex-demos/tree/main/nextjs-app-router)

이 페이지는 Next.js의 App Router 변형을 다룹니다.

<BetaAdmonition feature="Next.js 서버 렌더링 지원" verb="is" />

## 클라이언트 컴포넌트용 데이터 미리 로드

Convex에서 데이터를 미리 로드하고 Next.js
[서버 렌더링](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)을 활용하면서 초기 페이지 로드 후에도 반응성을 유지하려면
[`convex/nextjs`](/api/modules/nextjs)의
[`preloadQuery`](/api/modules/nextjs#preloadquery)를 사용하세요.

[서버 컴포넌트](https://nextjs.org/docs/app/building-your-application/rendering/server-components)에서
`preloadQuery`를 호출하세요:

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={PreloadQuery}
  sourceJS={PreloadQuery}
/>

[클라이언트 컴포넌트](https://nextjs.org/docs/app/building-your-application/rendering/client-components)에서
[`usePreloadedQuery`](/api/modules/react#usepreloadedquery)를 호출하세요:

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={UsePreloadedQueryTS}
  sourceJS={UsePreloadedQueryJS}
/>

[`preloadQuery`](/api/modules/nextjs#preloadquery)는 세 가지 인수를 받습니다:

1. 쿼리 참조
2. 선택적으로 쿼리에 전달되는 인수 객체
3. 선택적으로 [NextjsOptions](/api/modules/nextjs#nextjsoptions) 객체

`preloadQuery`는
[`cache: 'no-store'` 정책](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)을 사용하므로 이를 사용하는 서버 컴포넌트는
[정적 렌더링](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)에 적합하지 않습니다.

### 쿼리 결과 사용하기

[`preloadQuery`](/api/modules/nextjs#preloadquery)는 `usePreloadedQuery`에 전달해야 하는 불투명한 `Preloaded` 페이로드를 반환합니다. 쿼리의 반환 값을 사용하고 싶다면, 예를 들어 클라이언트 컴포넌트를 렌더링할지 여부를 결정하기 위해 `Preloaded` 페이로드를
[`preloadedQueryResult`](/api/modules/nextjs#preloadedqueryresult) 함수에 전달할 수 있습니다.

## 서버 컴포넌트를 렌더링하는 데 Convex 사용하기

서버에서 Convex 데이터가 필요한 경우
[서버 컴포넌트](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching)에서 Convex의 데이터를 로드할 수 있지만 반응형이 아닙니다. 이를 위해 `convex/nextjs`의
[`fetchQuery`](/api/modules/nextjs#fetchquery) 함수를 사용하세요:

<TSAndJSSnippet
  title="app/StaticTasks.tsx"
  sourceTS={FetchQuery}
  sourceJS={FetchQuery}
/>

## 서버 액션 및 Route Handler

Next.js는 Convex
[HTTP 액션](/functions/http-actions.mdx)과 유사한 HTTP 요청 처리 라우트 빌드를 지원합니다.
[서버 액션](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)이나
[Route Handler](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)에서 다른 데이터베이스 서비스를 사용하는 것처럼 Convex를 사용할 수 있습니다.

서버 액션이나 Route Handler에서 Convex 데이터를 로드하고 편집하려면 `fetchQuery`, `fetchMutation` 및 `fetchAction` 함수를 사용할 수 있습니다.

다음은 Convex 뮤테이션을 호출하는 인라인 서버 액션의 예입니다:

<TSAndJSSnippet
  title="app/example/page.tsx"
  sourceTS={ServerActionTS}
  sourceJS={ServerActionJS}
/>

다음은 Convex 뮤테이션을 호출하는 Route Handler의 예입니다:

<TSAndJSSnippet
  title="app/api/route.ts"
  sourceTS={RouteHandlerTS}
  sourceJS={RouteHandlerJS}
/>

## 서버 측 인증

서버 렌더링 중 Convex에 인증된 요청을 하려면 세 번째 옵션 인수에서
[`preloadQuery`](/api/modules/nextjs#preloadquery) 또는
[`fetchQuery`](/api/modules/nextjs#fetchquery)에 JWT 토큰을 전달하세요:

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={AuthedPreloadQuery}
  sourceJS={AuthedPreloadQuery}
  snippet="example"
/>

`getAuthToken`의 구현은 인증 공급자에 따라 다릅니다.

<Tabs>
<TabItem value="clerk" label="Clerk">
```ts title="app/auth.ts"
import { auth } from "@clerk/nextjs/server";

export async function getAuthToken() {
  return (await (await auth()).getToken({ template: "convex" })) ?? undefined;
}
```
</TabItem>
<TabItem value="auth0" label="Auth0">
```ts title="app/auth.ts"
// You'll need v4.3 or later of @auth0/nextjs-auth0
import { getSession } from '@auth0/nextjs-auth0';

export async function getAuthToken() {
  const session = await getSession();
  const idToken = session.tokenSet.idToken;
  return idToken;
}
```
</TabItem>
</Tabs>

## Convex 배포 URL 구성하기

클라이언트 컴포넌트에서 사용하는 Convex 훅은
[Next.js 빠른 시작](/quickstart/nextjs.mdx)에 표시된 대로 `ConvexReactClient` 생성자를 통해 구성됩니다.

서버 컴포넌트, 서버 액션 및 Route Handler에서 `preloadQuery`, `fetchQuery`, `fetchMutation` 및 `fetchAction`을 사용하려면 다음 중 하나를 수행해야 합니다:

1. Convex 배포 URL로 설정된 `NEXT_PUBLIC_CONVEX_URL` 환경 변수를 가지고 있거나
2. `preloadQuery`, `fetchQuery`, `fetchMutation` 또는 `fetchAction`의 세 번째 인수에
   [`url` 옵션](/api/modules/nextjs#nextjsoptions)을 전달합니다

## 일관성

[`preloadQuery`](/api/modules/nextjs#preloadquery)와
[`fetchQuery`](/api/modules/nextjs#fetchquery)는 내부적으로 `ConvexHTTPClient`를 사용합니다. 이 클라이언트는 상태를 유지하지 않습니다. 즉, `preloadQuery`에 대한 두 번의 호출이 동일한 데이터베이스 상태를 기반으로 일관된 데이터를 반환한다는 보장이 없습니다. 이는 더 전통적인 데이터베이스와 유사하지만
`ConvexReactClient`가 제공하는
[보장된 일관성](/client/react.mdx#consistency)과는 다릅니다.

일관되지 않은 UI 렌더링을 방지하려면 동일한 페이지에서 여러 `preloadQuery` 호출을 사용하지 마세요.
