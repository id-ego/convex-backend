---
title: "낙관적 업데이트"
slug: "optimistic-updates"
hidden: false
sidebar_position: 90
description: "낙관적 UI 업데이트로 React 앱의 응답성을 높이세요"
---

import Simple from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesSimple.tsx";
import ComplexTS from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesComplex.tsx";
import ComplexJS from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesComplexJS.jsx";

Convex 쿼리가 완전히 반응형이더라도 때때로 뮤테이션 변경사항이 클라이언트로 전파되기 전에 UI를 업데이트하고 싶을 수 있습니다. 이를 위해 뮤테이션의 일부로 실행되도록 _낙관적 업데이트_를 구성할 수 있습니다.

낙관적 업데이트는 앱의 응답성을 높이는 데 사용되는 쿼리 결과에 대한 임시 로컬 변경사항입니다. 이러한 업데이트는
[`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
구성 옵션으로 뮤테이션 호출에 등록된 함수에 의해 수행됩니다.

낙관적 업데이트는 뮤테이션이 시작될 때 실행되고, 로컬 쿼리 결과가 변경되면 다시 실행되며, 뮤테이션이 완료되면 롤백됩니다.

## 간단한 예제

다음은 간단한 카운터 앱의 `increment` 뮤테이션에 낙관적 업데이트를 추가하는 방법입니다:

<TSAndJSSnippet
  title="src/IncrementCounter.tsx"
  sourceTS={Simple}
  sourceJS={Simple}
/>

낙관적 업데이트는
[`localStore`](/api/interfaces/browser.OptimisticLocalStore), Convex 클라이언트의 내부 상태 뷰를 받고, 그 다음 뮤테이션에 대한 인수를 받습니다.

이 낙관적 업데이트는 `api.counter.get` 쿼리가 로드된 경우 `increment`만큼 더 높게 업데이트합니다.

## 복잡한 예제

다중 채널 채팅 앱에 낙관적 업데이트를 추가하려는 경우 다음과 같이 보일 수 있습니다:

<TSAndJSSnippet
  title="src/MessageSender.tsx"
  sourceTS={ComplexTS}
  sourceJS={ComplexJS}
/>

이 낙관적 업데이트는 현재 채널의 `api.messages.list` 쿼리를 새 메시지를 포함하도록 변경합니다. 새로 생성된 메시지 객체는 서버의 `api.messages.list` 쿼리에서 생성된 실제 메시지의 구조와 일치해야 합니다.

이 메시지는 클라이언트의 현재 시간(서버가 아님)을 포함하기 때문에 뮤테이션이 실행된 후 `api.messages.list` 쿼리와 불가피하게 일치하지 않습니다. 괜찮습니다! Convex 클라이언트는 뮤테이션이 완료되고 쿼리가 업데이트된 후 이 업데이트를 롤백하는 것을 처리합니다. 낙관적 업데이트에 작은 실수가 있더라도 UI는 항상 결국 올바른 값을 렌더링합니다.

마찬가지로 업데이트는
`new Id("messages", crypto.randomUUID())`로 임시 `Id`를 생성합니다. 이것도 롤백되고 서버가 할당하면 실제 ID로 교체됩니다.

마지막으로 이 업데이트는 `existingMessages.push(newMessage)`를 사용하는 대신 새 메시지 배열을 생성한다는 점에 유의하세요. 이것은 중요합니다! 낙관적 업데이트 내부에서 객체를 변경하면 클라이언트의 내부 상태가 손상되어 예상치 못한 결과가 발생합니다. 낙관적 업데이트 내부에서는 항상 새 객체를 생성하세요.

## 더 알아보기

자세한 내용은 API 문서를 확인하세요:

- [`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
- [`OptimisticUpdate`](/api/modules/browser#optimisticupdate)
- [`OptimisticLocalStore`](/api/interfaces/browser.OptimisticLocalStore)

실습 경험을 원하신다면
[튜토리얼 앱](https://github.com/get-convex/convex-tutorial)에 낙관적 업데이트를 추가해보세요! 그렇게 하면 앱이 약간 더 빠르게 느껴지는 것을 알 수 있을 것입니다. Convex는 이미 꽤 빠릅니다! 그러나 그 외에는 동일하게 작동합니다.

더 탐구하려면 이 업데이트에 실수를 삽입해보세요! 낙관적 업데이트가 적용되었다가 롤백되는 깜박임을 보게 될 것입니다.
