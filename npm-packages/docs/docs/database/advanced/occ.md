---
title: "OCC와 원자성"
slug: "occ"
hidden: false
sidebar_position: 500
todo: Push under mutations, or inline, or kill (move to Stack)
description:
  "Convex의 낙관적 동시성 제어와 트랜잭션 원자성"
---

[쿼리](/functions/query-functions.mdx)에서 낙관적 동시성 제어(OCC)가 Convex 내에서 사용되는 방식에서 결정론이 중요하다고 언급했습니다. 이 섹션에서는 _이유_에 대해 훨씬 더 깊이 있게 살펴보겠습니다.

## Convex Financial, Inc.

은행 앱을 만든다고 상상해보세요. 따라서 데이터베이스는 잔액이 있는 계정을 저장합니다. 사용자들이 서로에게 돈을 줄 수 있게 하고 싶어서, 한 사용자의 계정에서 다른 사용자의 계정으로 자금을 이체하는 뮤테이션 함수를 작성합니다.

해당 트랜잭션의 한 번 실행은 Alice의 계정 잔액을 읽은 다음 Bob의 잔액을 읽을 수 있습니다. 그런 다음 Alice의 계정에서 $5를 차감하고 Bob의 잔액을 동일한 $5만큼 증가시키는 것을 제안합니다.

다음은 의사 코드입니다:

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
WRITE Bob $16
```

이 원장 잔액 이체는 이러한 쓰기 작업이 함께만 적용될 것이라는 보장을 요구하는 고전적인 데이터베이스 시나리오입니다. 하나의 작업만 성공한다면 정말 나쁜 일입니다!

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
*crash* // 은행에서 $5 손실
```

이런 일이 절대 일어날 수 없다는 보장이 필요합니다. 트랜잭션 원자성이 필요하며, Convex가 이를 제공합니다.

데이터 정확성 문제는 훨씬 더 깊습니다. 동일한 레코드를 읽고 편집하는 동시 트랜잭션은 _데이터 경합_을 만들 수 있습니다.

우리 앱의 경우 누군가가 우리가 읽은 직후에 Alice의 잔액을 차감하는 것이 완전히 가능합니다. 아마도 그녀가 공항에서 직불 카드로 코카콜라 제로를 $3에 샀을 수 있습니다.

```
$5 이체                           $3 직불 카드 청구
----------------------------------------------------------
$14 <- READ Alice
$11 <- READ Bob
                                        $14 <- READ Alice
                                        WRITE Alice $11
WRITE Alice $9 // 무료 콜라!
WRITE Bob $16
```

분명히, 이러한 유형의 데이터 경합이 발생하는 것을 방지해야 합니다. 이러한 동시 충돌을 처리하는 방법이 필요합니다. 일반적으로 두 가지 일반적인 접근 방식이 있습니다.

대부분의 전통적인 데이터베이스는 _비관적 잠금_ 전략을 선택합니다. (이 경우 비관주의는 전략이 충돌이 미리 일어날 것이라고 가정하여 이를 방지하려고 한다는 것을 의미합니다.) 비관적 잠금을 사용하면 먼저 Alice의 레코드에 대한 잠금을 획득한 다음 Bob의 레코드에 대한 잠금을 획득해야 합니다. 그런 다음 트랜잭션을 수행할 수 있으며, 해당 레코드를 건드려야 하는 다른 트랜잭션은 모두 완료되고 모든 쓰기가 커밋될 때까지 기다릴 것입니다.

수십 년의 경험 후, 비관적 잠금의 단점은 잘 이해되고 부정할 수 없습니다. 가장 큰 제한은 실제 네트워크와 컴퓨터가 본질적으로 신뢰할 수 없다는 데서 발생합니다. 어떤 이유로든 잠금 보유자가 트랜잭션 중간에 사라지면, 해당 레코드 중 하나를 수정하려는 다른 모든 사람이 무기한 대기하게 됩니다. 좋지 않습니다!

낙관적 동시성 제어는 이름에서 알 수 있듯이 낙관적입니다. 트랜잭션이 성공할 것이라고 가정하고 미리 어떤 것도 잠그는 것에 대해 걱정하지 않습니다. 매우 대담합니다! 어떻게 그렇게 확신할 수 있을까요?

읽은 레코드 버전("읽기 집합")을 기반으로 레코드를 쓰기 위한 _선언적 제안_으로 트랜잭션을 처리함으로써 이를 수행합니다. 트랜잭션이 끝날 때, 읽기 집합의 모든 버전이 여전히 해당 레코드의 최신 버전인 경우 모든 쓰기가 커밋됩니다. 이것은 동시 충돌이 발생하지 않았음을 의미합니다.

이제 버전 읽기 집합을 사용하여 OCC가 위의 탄산음료 재앙을 어떻게 방지했을지 살펴보겠습니다:

```
$5 이체                           $3 직불 카드 청구
----------------------------------------------------------
(v1, $14) <- READ Alice
(v7, $11) <- READ Bob
                                        (v1, $14) <- READ Alice
                                        WRITE Alice $11
                                        IF Alice.v = v1

WRITE Alice = $9, Bob = $16
    IF Alice.v = v1, Bob.v = v7 // 실패! Alice는 = v2
```

이것은 HEAD에 있지 않아서 Git 저장소를 푸시할 수 없는 것과 유사합니다. 그 상황에서는 풀을 해야 하고, 리베이스나 병합 등을 해야 한다는 것을 모두 알고 있습니다.

## OCC가 실패할 때, 결정론이 승리합니다

순진한 낙관적 동시성 제어 솔루션은 Git이 하는 것과 동일한 방식으로 이를 해결하는 것입니다: 사용자/애플리케이션이 충돌을 해결하고 재시도해도 안전한지 결정하도록 요구합니다.

그러나 Convex에서는 그렇게 할 필요가 없습니다. 트랜잭션이 결정론적이라는 것을 알고 있습니다. Stripe에 청구하지 않았고, 파일 시스템에 영구 값을 쓰지 않았습니다. 적용되지 않은 Convex 테이블에 대한 일부 원자적 변경을 제안하는 것 외에는 전혀 효과가 없었습니다.

결정론은 단순히 트랜잭션을 다시 실행할 수 있다는 것을 의미합니다. 일시적인 데이터 경합에 대해 걱정할 필요가 없습니다. 충돌 없이 트랜잭션을 실행하는 데 성공할 때까지 필요한 경우 여러 번 재시도를 실행할 수 있습니다.

<Admonition type="tip">

사실, Git 비유는 매우 적절합니다. OCC 충돌은 HEAD가 오래되어 푸시할 수 없다는 것을 의미하므로 변경 사항을 리베이스하고 다시 시도해야 합니다. 그리고 결정론은 "병합 충돌"이 절대 없다는 것을 보장하므로 (Git과 달리) 이 리베이스 작업은 개발자 개입 없이 항상 결국 성공할 것입니다.

</Admonition>

## 스냅샷 격리 vs 직렬화 가능성

낙관적 다중 버전 동시성 제어 데이터베이스가
[스냅샷 격리](https://en.wikipedia.org/wiki/Snapshot_isolation) 보장을 제공하는 것은 일반적입니다. 이
[격리 수준](<https://en.wikipedia.org/wiki/Isolation_(database_systems)>)은
모든 트랜잭션이 데이터의 원자적 스냅샷에서 실행되는 환상을 제공하지만
특정 동시 트랜잭션 조합이 잘못된 결과를 초래할 수 있는
[이상 현상](https://en.wikipedia.org/wiki/Snapshot_isolation#Definition)에 취약합니다. Convex의 낙관적 동시성 제어 구현은 대신 진정한
[직렬화 가능성](https://en.wikipedia.org/wiki/Serializability)을 제공하며 동시에 발행되는 트랜잭션에 관계없이 올바른 결과를 생성합니다.

## 이에 대해 생각할 필요가 없습니다

이 접근 방식의 아름다움은 뮤테이션 함수가 _항상 성공_할 것처럼 간단히 작성할 수 있고, 항상 원자적임을 보장받을 수 있다는 것입니다.

Convex가 어떻게 작동하는지에 대한 순수한 호기심 외에도, 일상적으로 테이블과 문서를 변경할 때 충돌, 잠금 또는 원자성에 대해 걱정할 필요가 없습니다. 뮤테이션 함수를 작성하는 "명백한 방법"이 그냥 작동할 것입니다.
