---
title: 액션
sidebar_position: 30
description: "Convex에서 타사 서비스 및 외부 API 호출하기"
---

import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/actionsConstructor.ts";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContext.ts";
import ContextRunQuery from "!!raw-loader!@site/../private-demos/snippets/convex/myFunctions.ts";
import ContextRunMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContextRunMutation.ts";
import CircularError from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularError.ts";
import CircularErrorFixedResults from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedResults.ts";
import CircularErrorFixedReturn from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedReturn.ts";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNPM.ts";
import Node from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNode.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/actionsCall.tsx";
import ScheduleFromMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsScheduleFromMutation.ts";

액션은 [Stripe](https://stripe.com)를 통한 결제 처리와 같은 작업을 수행하기 위해 타사 서비스를 호출할 수 있습니다. Convex의 JavaScript 환경 또는 Node.js에서 실행될 수 있습니다. [쿼리](/functions/query-functions.mdx) 및 [뮤테이션](/functions/mutation-functions.mdx)을 호출하여 데이터베이스와 간접적으로 상호 작용할 수 있습니다.

**예제:**
[GIPHY 액션](https://github.com/get-convex/convex-demos/tree/main/giphy-action)

## 액션 이름

액션은 쿼리와 동일한 명명 규칙을 따릅니다. [쿼리 이름](/functions/query-functions.mdx#query-names)을 참조하세요.

## `action` 생성자

Convex에서 액션을 선언하려면 action 생성자 함수를 사용합니다. 액션을 수행하는 `handler` 함수가 포함된 객체를 전달합니다:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

쿼리와 달리 액션은 값을 반환할 수도 있고 반환하지 않을 수도 있습니다.

### 액션 인수 및 응답

액션 인수 및 응답은 [뮤테이션](/functions/mutation-functions.mdx#mutation-arguments)과 동일한 규칙을 따릅니다:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  title="convex/myFunctions.ts"
/>

handler 함수의 첫 번째 인수는 액션 컨텍스트용으로 예약되어 있습니다.

### 액션 컨텍스트

`action` 생성자는 [ActionCtx](/api/interfaces/server.GenericActionCtx) 객체를 handler 함수의 첫 번째 인수로 전달하여 데이터베이스 및 기타 Convex 기능과의 상호 작용을 가능하게 합니다:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

액션 컨텍스트의 어떤 부분을 사용할지는 액션이 수행해야 하는 작업에 따라 다릅니다:

- 데이터베이스에서 데이터를 읽으려면 `runQuery` 필드를 사용하고, 읽기를 수행하는 쿼리를 호출합니다:

  <TSAndJSSnippet
    sourceTS={ContextRunQuery}
    sourceJS={ContextRunQuery}
    snippet="action"
    title="convex/myFunctions.ts"
  />

  여기서 `readData`는 클라이언트에 직접 노출하고 싶지 않기 때문에 [내부 쿼리](/functions/internal-functions.mdx)입니다. 액션, 뮤테이션, 쿼리는 동일한 파일에 정의할 수 있습니다.

- 데이터베이스에 데이터를 쓰려면 `runMutation` 필드를 사용하고, 쓰기를 수행하는 뮤테이션을 호출합니다:

  <TSAndJSSnippet
    sourceTS={ContextRunMutation}
    sourceJS={ContextRunMutation}
    title="convex/myFunctions.ts"
  />

  사용자가 뮤테이션을 직접 호출하는 것을 방지하려면 [내부 뮤테이션](/functions/internal-functions.mdx)을 사용하세요.

  쿼리와 마찬가지로 액션과 뮤테이션을 동일한 파일에 정의하는 것이 편리한 경우가 많습니다.

- 파일 저장을 위한 업로드 URL을 생성하려면 `storage` 필드를 사용합니다. [파일 스토리지](/file-storage.mdx)에 대해 자세히 알아보세요.
- 사용자 인증을 확인하려면 `auth` 필드를 사용합니다. 인증은 액션에서 쿼리 및 뮤테이션을 호출할 때 자동으로 전파됩니다. [인증](/auth.mdx)에 대해 자세히 알아보세요.
- 미래에 실행될 함수를 예약하려면 `scheduler` 필드를 사용합니다. [예약된 함수](/scheduling/scheduled-functions.mdx)에 대해 자세히 알아보세요.
- 벡터 인덱스를 검색하려면 `vectorSearch` 필드를 사용합니다. [벡터 검색](/search/vector-search.mdx)에 대해 자세히 알아보세요.

### 순환 타입 추론 처리

<Details summary={<>
TypeScript 오류 해결하기: 일부 액션이 <code>암시적으로 'any' 타입을 가집니다. 타입 주석이 없고 자체 초기화에서 직접 또는 간접적으로 참조되기 때문입니다.</code>
</>}>

액션의 반환 값이 `ctx.runQuery` 또는 `ctx.runMutation` 호출 결과에 의존하는 경우, TypeScript는 액션의 반환 타입을 추론할 수 없다고 불평합니다. 다음은 이 문제의 최소 예제입니다:

<Snippet
  title="convex/myFunctions.ts"
  source={CircularError}
  snippet="tsError"
/>

이 문제를 해결하려면 두 가지 옵션이 있습니다:

1. handler 함수의 반환 값을 명시적으로 타입 지정합니다:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedReturn}
     snippet="fixed"
     highlightPatterns={["null"]}
   />
2. `ctx.runQuery` 또는 `ctx.runMutation` 호출의 결과를 명시적으로 타입 지정합니다:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedResults}
     snippet="fixed"
     highlightPatterns={["null"]}
   />

TypeScript는 타입 주석이 호출된 쿼리 또는 뮤테이션이 반환하는 것과 일치하는지 확인하므로 타입 안정성을 잃지 않습니다.

이 간단한 예제에서 쿼리의 반환 타입은 `null`이었습니다. 결과에 주석을 달 때 도움이 될 수 있는 다른 타입은 [TypeScript](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers) 페이지를 참조하세요.

</Details>

## 런타임 선택하기 ("use node")

액션은 Convex의 사용자 정의 JavaScript 환경 또는 Node.js에서 실행될 수 있습니다.

기본적으로 액션은 Convex의 환경에서 실행됩니다. 이 환경은 `fetch`를 지원하므로 `fetch`를 사용하여 타사 API를 호출하려는 액션은 이 환경에서 실행할 수 있습니다:

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

Convex의 환경에서 실행되는 액션은 액션을 실행하기 전에 시작하는 데 추가 시간이 필요하지 않기 때문에 Node.js에 비해 더 빠릅니다(콜드 스타트). 또한 다른 Convex 함수와 동일한 파일에 정의할 수 있습니다. 쿼리 및 뮤테이션과 마찬가지로 NPM 패키지를 가져올 수 있지만 모든 패키지가 지원되는 것은 아닙니다.

지원되지 않는 NPM 패키지 또는 Node.js API가 필요한 액션은 파일 상단에 `"use node"` 지시어를 추가하여 Node.js에서 실행되도록 구성할 수 있습니다. `"use node";` 지시어가 있는 파일에서는 다른 Convex 함수를 정의할 수 없습니다.

<TSAndJSSnippet
  sourceTS={Node}
  sourceJS={Node}
  highlightPatterns={["use node"]}
  title="convex/myAction.ts"
/>

두 가지 [Convex 런타임](/functions/runtimes.mdx)에 대해 자세히 알아보세요.

## 헬퍼를 통한 액션 코드 분할

<>
  {/* Fragment for Prettier */}
  [쿼리](/functions/query-functions.mdx#splitting-up-query-code-via-helpers) 및 [뮤테이션](/functions/mutation-functions.mdx#splitting-up-mutation-code-via-helpers)과 마찬가지로 액션의 코드를 분할하거나 여러 Convex 함수에서 로직을 재사용하기 위해 헬퍼 <LanguageSelector verbose /> 함수를 정의하고 호출할 수 있습니다.

하지만 [ActionCtx](/api/interfaces/server.GenericActionCtx)는 [QueryCtx](/generated-api/server.md#queryctx) 및 [MutationCtx](/generated-api/server.md#mutationctx)와 `auth` 필드만 공통으로 가지고 있다는 점에 유의하세요.

</>

## 클라이언트에서 액션 호출하기

[React](/client/react.mdx)에서 액션을 호출하려면 생성된 [`api`](/generated-api/api) 객체와 함께 [`useAction`](/api/modules/react#useaction) 훅을 사용합니다.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/myApp.tsx" />

[뮤테이션](/functions/mutation-functions.mdx#calling-mutations-from-clients)과 달리 단일 클라이언트의 액션은 병렬화됩니다. 각 액션은 서버에 도달하는 즉시 실행됩니다(동일한 클라이언트의 다른 액션 및 뮤테이션이 실행 중이더라도). 앱이 다른 액션 또는 뮤테이션 이후에 액션이 실행되는 것에 의존하는 경우, 관련 이전 함수가 완료된 후에만 액션을 트리거해야 합니다.

**참고:** 대부분의 경우 클라이언트에서 직접 액션을 호출하는 것은 **안티패턴**입니다. 대신 클라이언트가 데이터베이스에 쓰기로 사용자 의도를 캡처하는 [뮤테이션](/functions/mutation-functions.mdx)을 호출하고 [액션을 예약](/scheduling/scheduled-functions.mdx)하도록 하세요:

<TSAndJSSnippet
  sourceTS={ScheduleFromMutation}
  sourceJS={ScheduleFromMutation}
  title="convex/myFunctions.ts"
/>

이렇게 하면 뮤테이션이 사용자가 동일한 액션을 두 번 실행하는 것을 방지하는 것과 같은 불변성을 강제할 수 있습니다.

## 제한사항

액션은 10분 후 타임아웃됩니다.
[Node.js](/functions/runtimes.mdx#nodejs-runtime) 및 [Convex 런타임](/functions/runtimes.mdx#default-convex-runtime)의 메모리 제한은 각각 512MB 및 64MB입니다. 더 높은 제한 구성이 필요한 사용 사례가 있는 경우 [문의하세요](/production/contact.md).

액션은 쿼리, 뮤테이션 실행 또는 fetch 요청 수행과 같은 최대 1000개의 동시 작업을 수행할 수 있습니다.

다른 제한사항에 대한 정보는 [여기](/production/state/limits.mdx)를 참조하세요.

## 오류 처리

쿼리 및 뮤테이션과 달리 액션은 부작용이 있을 수 있으므로 오류가 발생했을 때 Convex에서 자동으로 재시도할 수 없습니다. 예를 들어, 액션이 Stripe를 호출하여 고객 인보이스를 전송한다고 가정해 보겠습니다. HTTP 요청이 실패하면 Convex는 인보이스가 이미 전송되었는지 여부를 알 수 있는 방법이 없습니다. 일반 백엔드 코드와 마찬가지로 액션에서 발생한 오류를 처리하고 적절한 경우 액션 호출을 재시도하는 것은 호출자의 책임입니다.

## 대기 중인 Promise

액션 내에서 생성된 모든 Promise를 await해야 합니다. 함수가 반환될 때 여전히 실행 중인 비동기 작업은 완료될 수도 있고 완료되지 않을 수도 있습니다. 또한 Node.js 실행 환경이 액션 호출 간에 재사용될 수 있으므로 대기 중인 Promise로 인해 후속 액션 호출에서 오류가 발생할 수 있습니다.

## 모범 사례

### `await ctx.runAction`은 JS 런타임 간 전환에만 사용해야 합니다

**이유는?** `await ctx.runAction`은 또 다른 Convex 서버 함수의 오버헤드를 발생시킵니다. 추가 함수 호출로 계산되고, 자체 시스템 리소스를 할당하며, 이 호출을 기다리는 동안 부모 액션 호출이 모든 리소스를 보유한 채 고정됩니다. 이러한 호출을 충분히 쌓으면 앱이 크게 느려질 수 있습니다.

**해결 방법:** 이 API가 존재하는 이유는 [Node.js 환경](/functions/runtimes.mdx)에서 코드를 실행할 수 있도록 하기 위해서입니다. 동일한 런타임에 있는 다른 액션에서 액션을 호출하려는 경우(일반적인 경우) 가장 좋은 방법은 호출하려는 코드를 TypeScript [헬퍼 함수](/understanding/best-practices/best-practices.mdx#use-helper-functions-to-write-shared-code)로 추출하고 대신 헬퍼를 호출하는 것입니다.

### `await ctx.runMutation` / `await ctx.runQuery` 피하기

```ts
// ❌
const foo = await ctx.runQuery(...)
const bar = await ctx.runQuery(...)

// ✅
const fooAndBar = await ctx.runQuery(...)
```

**이유는?** 여러 runQuery / runMutation은 별도의 트랜잭션에서 실행되며 서로 일관성이 보장되지 않습니다(예: foo와 bar가 동일한 문서를 읽고 두 가지 다른 결과를 반환할 수 있음). 반면 단일 runQuery / runMutation은 항상 일관성이 있습니다. 또한 필요하지 않을 때 여러 함수 호출에 대한 비용을 지불하고 있습니다.

**해결 방법:** 두 가지 작업을 모두 수행하는 새로운 내부 쿼리/뮤테이션을 만듭니다. 두 함수의 코드를 헬퍼로 리팩토링하면 원래 함수를 유지하면서 두 가지 작업을 모두 수행하는 새 내부 함수를 쉽게 만들 수 있습니다. 액션 코드를 리팩토링하여 모든 데이터베이스 액세스를 "일괄 처리"해 보세요.

주의사항: 의도적으로 단일 트랜잭션에 맞지 않는 더 많은 데이터를 처리하려고 할 때(예: 마이그레이션 실행, 라이브 집계 수행) 별도의 runQuery / runMutation 호출이 유효합니다.
