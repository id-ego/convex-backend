---
title: 쿼리
sidebar_position: 10
description: "캐싱 및 반응성과 함께 데이터베이스에서 데이터 가져오기"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/queriesExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/queriesConstructor.ts";
import ArgsWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidation.ts";
import ArgsWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidationJS.js";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContext.ts";
import ContextDB from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContextDB.ts";
import Helper from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelper.ts";
import HelperJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelperJS.js";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/queriesNPM.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/queriesCall.tsx";

쿼리는 백엔드 API의 핵심입니다. 데이터베이스에서 데이터를 가져오고, 인증을 확인하거나 다른 비즈니스 로직을 수행하고, 클라이언트 애플리케이션에 데이터를 반환합니다.

다음은 명명된 인수를 받아 데이터베이스에서 데이터를 읽고 결과를 반환하는 예제 쿼리입니다:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

쿼리를 직접 작성하는 방법을 이해하려면 계속 읽어보세요.

## 쿼리 이름

쿼리는 `convex/` 디렉토리 내의 <LanguageSelector verbose /> 파일에 정의됩니다.

파일의 경로와 이름, 함수가 파일에서 export되는 방식에 따라 클라이언트가 호출할 이름이 결정됩니다:

```ts title="convex/myFunctions.ts"
// 이 함수는 `api.myFunctions.myQuery`로 참조됩니다.
export const myQuery = …;

// 이 함수는 `api.myFunctions.sum`으로 참조됩니다.
export const sum = …;
```

API를 구조화하려면 `convex/` 디렉토리 내에 디렉토리를 중첩할 수 있습니다:

```ts title="convex/foo/myQueries.ts"
// 이 함수는 `api.foo.myQueries.listMessages`로 참조됩니다.
export const listMessages = …;
```

기본 export는 `default`라는 이름을 받습니다.

```ts title="convex/myFunctions.ts"
// 이 함수는 `api.myFunctions.default`로 참조됩니다.
export default …;
```

동일한 규칙이 [뮤테이션](/functions/mutation-functions.mdx) 및 [액션](/functions/actions.mdx)에 적용되며, [HTTP 액션](/functions/http-actions.mdx)은 다른 라우팅 접근 방식을 사용합니다.

JavaScript 및 TypeScript 이외의 언어의 클라이언트 라이브러리는 API 객체 대신 문자열을 사용합니다:

- `api.myFunctions.myQuery`는 `"myFunctions:myQuery"`입니다.
- `api.foo.myQueries.myQuery`는 `"foo/myQueries:myQuery"`입니다.
- `api.myFunction.default`는 `"myFunction:default"` 또는 `"myFunction"`입니다.

## `query` 생성자

Convex에서 쿼리를 실제로 선언하려면 `query` 생성자 함수를 사용합니다. 쿼리 결과를 반환하는 `handler` 함수가 포함된 객체를 전달합니다:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

### 쿼리 인수

쿼리는 명명된 인수를 받아들입니다. 인수 값은 handler 함수의 두 번째 매개변수의 필드로 액세스할 수 있습니다:

<TSAndJSSnippet
  sourceTS={ArgsWithoutValidationTS}
  sourceJS={ArgsWithoutValidationJS}
  title="convex/myFunctions.ts"
/>

인수 및 응답은 자동으로 직렬화 및 역직렬화되며 대부분의 값과 같은 JavaScript 데이터를 쿼리와 주고받을 수 있습니다.

인수의 타입을 선언하고 검증하려면 `v` 검증자를 사용하는 `args` 객체를 추가합니다:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  highlightPatterns={["args:"]}
  title="convex/myFunctions.ts"
/>

지원되는 타입 및 검증자의 전체 목록은 [인수 검증](/functions/validation.mdx)을 참조하세요.

handler 함수의 첫 번째 매개변수는 쿼리 컨텍스트를 포함합니다.

### 쿼리 응답

쿼리는 자동으로 직렬화 및 역직렬화되는 지원되는 [Convex 타입](/functions/validation.mdx)의 값을 반환할 수 있습니다.

쿼리는 유효한 Convex 값이 아닌 `undefined`를 반환할 수도 있습니다. 쿼리가 `undefined`를 반환하면 **클라이언트에서 `null`로 변환됩니다**.

### 쿼리 컨텍스트

`query` 생성자는 [QueryCtx](/generated-api/server.md#queryctx) 객체를 handler 함수의 첫 번째 매개변수로 전달하여 데이터를 가져오고 다른 Convex 기능을 사용할 수 있게 합니다:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

쿼리 컨텍스트의 어떤 부분을 사용할지는 쿼리가 수행해야 하는 작업에 따라 다릅니다:

- 데이터베이스에서 가져오려면 `db` 필드를 사용합니다. `db.get()`이 반환하는 Promise를 `await`할 수 있도록 handler 함수를 `async` 함수로 만듭니다:

  <TSAndJSSnippet
    sourceTS={ContextDB}
    sourceJS={ContextDB}
    highlightPatterns={["db."]}
    title="convex/myFunctions.ts"
  />

  [데이터 읽기](/database/reading-data/reading-data.mdx)에 대해 자세히 알아보세요.

- 저장된 파일에 대한 URL을 반환하려면 `storage` 필드를 사용합니다. [파일 스토리지](/file-storage.mdx)에 대해 자세히 알아보세요.
- 사용자 인증을 확인하려면 `auth` 필드를 사용합니다. [인증](/auth.mdx)에 대해 자세히 알아보세요.

## 헬퍼를 통한 쿼리 코드 분할

쿼리의 코드를 분할하거나 여러 Convex 함수에서 로직을 재사용하려는 경우 헬퍼 <LanguageSelector verbose /> 함수를 정의하고 호출할 수 있습니다:

<TSAndJSSnippet
  sourceTS={Helper}
  sourceJS={HelperJS}
  title="convex/myFunctions.ts"
/>

헬퍼를 `export`하여 여러 파일에서 사용할 수 있습니다. Convex 함수 외부에서는 호출할 수 없습니다.

TypeScript 타입에 대한 자세한 지침은 [서버 측 헬퍼 타입 주석 달기](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)를 참조하세요.

## NPM 패키지 사용하기

쿼리는 `node_modules`에 설치된 NPM 패키지를 가져올 수 있습니다. 모든 NPM 패키지가 지원되는 것은 아닙니다. 자세한 내용은 [런타임](/functions/runtimes.mdx#default-convex-runtime)을 참조하세요.

```sh
npm install @faker-js/faker
```

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

## 클라이언트에서 쿼리 호출하기

[React](/client/react.mdx)에서 쿼리를 호출하려면 생성된 [`api`](/generated-api/api) 객체와 함께 [`useQuery`](/client/react.mdx#fetching-data) 훅을 사용합니다.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/MyApp.tsx" />

쿼리를 호출할 수 있는 모든 방법은 [React](/client/react.mdx) 클라이언트 문서를 참조하세요.

## 캐싱 & 반응성 & 일관성

쿼리에는 세 가지 훌륭한 속성이 있습니다:

1. **캐싱**: Convex는 쿼리 결과를 자동으로 캐시합니다. 많은 클라이언트가 동일한 인수로 동일한 쿼리를 요청하면 캐시된 응답을 받습니다.
2. **반응성**: 클라이언트는 쿼리를 구독하여 기본 데이터가 변경될 때 새 결과를 받을 수 있습니다.
3. **일관성**: 단일 쿼리 호출 내의 모든 데이터베이스 읽기는 동일한 논리적 타임스탬프에서 수행됩니다. 동시 쓰기는 쿼리 결과에 영향을 주지 않습니다.

이러한 속성을 갖기 위해 handler 함수는 _결정론적_이어야 합니다. 즉, 동일한 인수(쿼리 컨텍스트 포함)가 주어지면 동일한 응답을 반환합니다.

이러한 이유로 쿼리는 타사 API에서 `fetch`할 수 없습니다. 타사 API를 호출하려면 [액션](/functions/actions.mdx)을 사용하세요.

`Math.random()` 또는 `Date.now()`와 같은 비결정론적 언어 기능을 사용할 수 있는지 궁금할 수 있습니다. 짧은 대답은 Convex가 결정론적 제약 조건에 대해 생각할 필요가 없도록 이러한 기능을 구현한다는 것입니다.

자세한 내용은 [런타임](/functions/runtimes.mdx#default-convex-runtime)을 참조하세요.

## 제한사항

쿼리에는 한 번에 읽을 수 있는 데이터의 양에 제한이 있어 좋은 성능을 보장합니다. [읽기/쓰기 제한 오류](/functions/error-handling/error-handling.mdx#readwrite-limit-errors)에서 이러한 제한을 확인하세요.

다른 제한사항에 대한 정보는 [제한사항](/production/state/limits.mdx)을 참조하세요.
