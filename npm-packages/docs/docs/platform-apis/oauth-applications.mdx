---
title: OAuth Applications
sidebar_position: 10
---

# OAuth Applications

Convex는 서드파티 앱 개발자가 **Application Token**을 통해 사용자의 프로젝트를 대신 관리할 수 있도록 합니다.

Application Token은 OAuth 인증 코드 플로우를 통해 획득되며,
자세한 내용은 아래에 설명되어 있습니다.

OAuth 토큰에는 두 가지 유형이 있습니다:

- 팀 범위 토큰: 새 프로젝트를 생성하고, 프로젝트 내에서 새 배포를 생성하며,
  팀의 모든 프로젝트에 대한 데이터와 함수에 읽기 및 쓰기 액세스 권한을 가집니다.
- 프로젝트 범위 토큰: 특정 프로젝트 내에서 새 배포를 생성하고 데이터와 함수에 액세스할 수 있습니다.

<Admonition type="note">
  모든 Application Token은 사용을 승인한 멤버의 권한으로도 범위가 지정됩니다.
  멤버가 팀에서 제거되거나 권한이 변경되면 토큰의 권한도 변경됩니다.
</Admonition>

## 애플리케이션 생성

Application Token을 얻으려면 먼저 Convex에 OAuth 애플리케이션을 등록해야 하며,
[Team Settings](https://dashboard.convex.dev/team/settings/applications/oauth-apps)에서 수행할 수 있습니다.

애플리케이션을 등록하려면 애플리케이션 이름과 리디렉션 URI 세트를 제공해야 합니다.
리디렉션 URI는 사용자가 Convex 팀 또는 프로젝트에 대한 액세스를 승인한 후
애플리케이션으로 돌아가는 데 사용됩니다. 테스트용 [localhost](http://localhost)를
포함하여 최대 20개의 리디렉션 URI를 추가할 수 있습니다.

애플리케이션을 생성하면 "미확인(Unverified)" 상태가 됩니다. 미확인 상태에서는
자신의 팀에 대한 Application Token을 얻을 수 있지만 다른 팀에 대해서는 얻을 수 없습니다.
확인을 요청하기 전에 미확인 상태에서 애플리케이션을 테스트하는 것이 좋습니다.

애플리케이션 옆의 ⋮ 버튼을 클릭하고 "Request Verification"을 클릭하여 확인을 요청할 수 있습니다.

### 확인 요구사항

애플리케이션을 확인하고 모든 Convex 사용자가 액세스할 수 있도록 하려면
다음 기준을 충족해야 합니다:

- 애플리케이션 설명에 애플리케이션의 기능 및 계획된 향후 기능에 대한 설명이 포함되어 있어야 합니다.
- 애플리케이션 이름, 리디렉션 URI 및 리디렉션 URI의 콘텐츠가 다른 조직, 비즈니스 또는
  엔티티를 허위로 표현하지 않아야 합니다.
- 나열된 리디렉션 URI가 귀하의 조직에 속해야 합니다.

Convex 팀은 추가 정보가 필요한 경우 이메일로 확인 요청에 응답합니다.

## OAuth 구현

Convex는 [OAuth 2.0](https://oauth.net/2/) (RFC 6749)의
[Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/)
플로우를 구현합니다. Convex는 또한 보안을 향상시키기 위해
[PKCE 확장](https://oauth.net/2/pkce/) (RFC 7636)을 선택적으로 지원합니다.

- Convex는 팀 범위 토큰을 생성하는지 프로젝트 범위 토큰을 생성하는지에 따라
  두 개의 _authorization endpoint_ URL을 제공합니다:
  - `https://dashboard.convex.dev/oauth/authorize/team`
  - `https://dashboard.convex.dev/oauth/authorize/project`
- Convex의 **token endpoint**는 `https://api.convex.dev/oauth/token`입니다.

인증 플로우를 단계별로 안내하겠습니다. 그러나 필요한 URL과 API 호출을 구성하는 데
도움이 되는 OAuth 2.0 클라이언트 라이브러리를 사용하는 것이 좋습니다.

## 1단계: 사용자를 Convex의 authorization endpoint로 리디렉션

애플리케이션에서 사용자를 다음으로 이동시킵니다:

`https://dashboard.convex.dev/oauth/authorize[TOKEN_SCOPE]?client_id=[CLIENT_ID]&redirect_uri=[REDIRECT_URI]&response_type=code&state=[STATE]`

- `[TOKEN_SCOPE]`는 "team" 또는 "project"로 대체해야 합니다.
- `[CLIENT_ID]`는 Convex에서 할당한 앱의 클라이언트 ID로 대체해야 합니다.
- `[REDIRECT_URI]`는 애플리케이션 도메인의 URL입니다. 사용자가 승인한 후
  해당 URL로 다시 리디렉션됩니다.
  - **중요 참고사항**: 애플리케이션이 사용할 수 있는 모든 리디렉션 URI(아마도 하나만)를
    제공해야 합니다. 이는 악의적인 애플리케이션이 귀하의 애플리케이션으로 위장하지만
    다른 콜백으로 리디렉션하는 것을 방지하는 데 필요합니다.
- `[STATE]`는 선택적 임의 문자열입니다. 인코딩 방법은 사용자에게 달려 있지만,
  애플리케이션은 이를 사용하여 인증 토큰을 받은 후 수행할 작업을 결정합니다.

**모든 매개변수를 URI 인코딩해야 합니다!**

이렇게 하면 다음과 같은 페이지로 사용자가 이동합니다:

![OAuth authorization page](/screenshots/oauth-page.png)

여기서 사용자는 액세스를 승인할 팀을 선택할 수 있습니다. 프로젝트 플로우를 사용하는 경우
사용자는 기존 프로젝트를 선택하거나 새 프로젝트를 만들 수도 있습니다.
"Authorize"를 클릭하면 페이지가 리디렉션 URL로 리디렉션됩니다.

## 2단계: 콜백 받기

authorization endpoint는 `code` 및 `state` 쿼리 매개변수가 채워진
리디렉션 URI로 사용자를 이동시킵니다. `redirect_uri`가
`https://yourapp.example.com/cb`인 경우 결과는 다음과 같습니다:

`https://yourapp.example.com/cb?code=[CODE]&state=[STATE]`

여기서 `state`는 이전에 제공한 값과 동일하고 `code`는
`895c59eb98504a5bbaa7ad2e49cf4817`과 같이 무작위로 생성된 문자열입니다.
이 코드는 최종 인증 토큰이 **아닙니다** - 10분 이내에 교환해야 합니다.

## 3단계: 인증 코드를 프로젝트 토큰으로 교환

애플리케이션은 다음 엔드포인트에 HTTP POST 요청을 해야 합니다:

`https://api.convex.dev/oauth/token`

본문은 콘텐츠 유형이 `application/x-www-form-urlencoded`이어야 하며
다음과 같아야 합니다:

`client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&grant_type=authorization_code&redirect_uri=[REDIRECT_URI]&code=[CODE]`

- `client_id`는 authorization endpoint URL을 구성하는 데 사용된 것과 동일합니다.
- `client_secret`는 Convex에서 할당한 앱의 비밀입니다.
- `grant_type`는 항상 `authorization_code`입니다.
- `redirect_uri`는 authorization endpoint URL을 구성하는 데 사용된 것과 동일합니다.
- `code`는 콜백에 제공된 인증 코드입니다.
  - `code`는 액세스 토큰으로 _한 번만_ 교환할 수 있습니다.

제공된 모든 값이 정확하면 Convex의 API는 다음을 포함하는 JSON 응답을 반환합니다:

```jsx
{
	"access_token": "team:my-team|AAAAAA==",
	"token_type": "bearer"
}
```

`access_token`이 Application Token입니다!

# PKCE 사용 (RFC 7636)

Convex는 Authorization Code 부여 유형에 대한 이 확장을 지원합니다.
`S256` 방법만 허용됩니다. PKCE는 클라이언트 비밀이 공개되지 않은 경우에도
(예: 클라이언트 측 애플리케이션에 포함되어야 하는 경우)
유출된 인증 코드가 공격자에 의해 사용되는 것을 방지합니다.

OAuth 클라이언트 라이브러리는 일반적으로 이미 PKCE를 지원하지만 수동으로 구현하려면:

- 사용자 승인을 요청할 때마다 사용자를 리디렉션하기 전에
  `code_verifier`라는 임의의 문자열을 구성합니다. 임의의 32바이트 값을 생성하고
  base64url로 인코딩하는 것이 좋습니다.
- `code_challenge = base64url(sha256(code_verifier))`를 계산합니다.
  이것은 43자 문자열이 됩니다.
- 이전과 같이 authorization endpoint(`/oauth/authorize/[TOKEN_SCOPE]`)로
  사용자를 리디렉션하되, 추가로 `code_challenge=[CODE_CHALLENGE]&code_challenge_method=S256`
  매개변수를 제공합니다.
- 인증 코드를 토큰으로 교환할 때 추가로 `code_verifier=[CODE_VERIFIER]` 매개변수를 제공합니다.
