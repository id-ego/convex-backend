---
title: "로그 스트림"
sidebar_label: "로그 스트림"
sidebar_position: 2
description: "Convex 배포를 위한 로깅 통합 구성"
---

로그 스트림은 함수 실행 및 `console.log`와 같은 이벤트를 Convex 배포에서 Axiom, Datadog 또는 커스텀 웹훅과 같은 지원되는 대상으로 스트리밍할 수 있게 합니다.

Convex 배포에서 생성된 가장 최근 로그는 대시보드 [로그 페이지](/dashboard/deployments/logs.md), [Convex CLI](/cli.md) 또는 브라우저 콘솔에서 볼 수 있어 최근 로그를 빠르고 쉽게 볼 수 있는 방법을 제공합니다.

Axiom 또는 Datadog와 같은 타사 대상으로 로그 스트리밍하면 과거 로그 저장, 더 강력한 쿼리 및 데이터 시각화, 다른 도구(예: PagerDuty, Slack)와의 통합이 가능합니다.

<ProFeatureUpsell feature="로그 스트림" verb="require" />

## 로그 스트림 구성하기

현재 다음 로그 스트림을 지원하며, 더 많은 것을 지원할 계획입니다:

- [Axiom](https://www.axiom.co)
- [Datadog](https://www.datadoghq.com/)
- 커스텀 URL로의 웹훅

[통합 구성](/production/integrations/integrations.mdx#configuring-an-integration) 지침을 참조하세요.
각 로그 스트림에 필요한 구체적인 정보는 아래에 설명되어 있습니다.

### Axiom

Axiom 로그 스트림을 구성하려면 다음을 지정해야 합니다:

- [Axiom dataset](https://axiom.co/docs/reference/settings#dataset)의 이름
- Axiom [API 키](https://axiom.co/docs/reference/settings#api-token)
- Axiom으로 전송되는 모든 로그 이벤트에 포함될 속성과 값의 선택적 목록. 이들은 [Ingest API](https://axiom.co/docs/send-data/ingest#ingest-api)의 `attributes` 필드를 통해 전송됩니다.

Axiom에서 Convex 데이터셋을 구성할 때 Axiom에서 대시보드가 자동으로 생성됩니다. _Dashboards_ 탭의 _Integrations_ 섹션에서 찾을 수 있습니다. 대시보드 레이아웃을 사용자 정의하려면 [포크](https://axiom.co/docs/dashboards/create#fork-dashboards)할 수 있습니다.

![Axiom의 대시보드](/screenshots/axiom_dashboard.png)

### Datadog

Datadog 로그 스트림을 구성하려면 다음을 지정해야 합니다:

- Datadog 배포의 [사이트 위치](https://docs.datadoghq.com/getting_started/site/)
- Datadog [API 키](https://docs.datadoghq.com/account_management/api-app-keys/#add-an-api-key-or-client-token)
- Datadog로 전송되는 모든 페이로드에서 [`ddtags` 필드](https://docs.datadoghq.com/getting_started/tagging/)를 사용하여 전달될 쉼표로 구분된 태그 목록. 이는 Datadog 배포에 수집된 Convex 로그를 쿼리하거나 분류하는 데 유용할 수 있는 다른 메타데이터를 포함하는 데 사용될 수 있습니다.

### 웹훅

웹훅 로그 스트림은 가장 간단하고 일반적인 스트림으로, 구성한 모든 URL로 POST 요청을 통해 로그를 전송할 수 있습니다. 이 스트림을 설정하는 데 필요한 유일한 매개변수는 원하는 웹훅 URL입니다.

이 웹훅에 대한 요청은 본문으로 아래에 정의된 스키마의 이벤트 JSON 배열을 포함합니다.

## 로그 이벤트 스키마

<Admonition type="info">
  2024년 5월 23일 이전에 구성된 로그 스트림은 [이 페이지](/production/integrations/log-streams/legacy-event-schema.mdx)에 문서화된 레거시 형식을 사용합니다. 새 형식을 사용하도록 로그 스트림을 업데이트하는 것을 권장합니다.
</Admonition>

로그 이벤트는 복잡하고 타입 안전한 파이프라인을 구축할 수 있도록 잘 정의된 JSON 스키마를 가지고 있습니다.

모든 이벤트는 다음 세 가지 필드를 갖습니다:

- `topic`: 문자열, 로그 이벤트를 분류, `["verification", "console", "function_execution", "audit_log"]` 중 하나
- `timestamp`: 숫자, 정수로 표현된 밀리초 단위의 Unix epoch 타임스탬프
- `convex`: `deployment_name`, `deployment_type`, `project_name`, `project_slug`를 포함한 Convex 배포와 관련된 메타데이터가 포함된 객체

참고: Axiom 통합에서는 이벤트별 정보가 `data` 필드 아래에서 사용할 수 있습니다.

### `verification` 이벤트

로그 스트림이 작동하는지 확인하기 위해 전송되는 이벤트입니다. 스키마:

- `topic`: `"verification"`
- `timestamp`: 밀리초 단위의 Unix epoch 타임스탬프
- `message`: 문자열

### `console` 이벤트

[`console` API](/functions/debugging.mdx)를 통한 Convex 함수 로그입니다.

스키마:

- `topic`: `"console"`
- `timestamp`: 밀리초 단위의 Unix epoch 타임스탬프
- `function`: 객체, [함수 필드](/production/integrations/log-streams/log-streams.mdx#function-fields) 참조
- `log_level`: 문자열, `["DEBUG", "INFO", "LOG", "WARN", "ERROR"]` 중 하나
- `message`: 문자열, `console.log` 페이로드의 [`object-inspect`](https://www.npmjs.com/package/object-inspect) 표현
- `is_truncated`: 불리언, 이 메시지가 로깅 제한에 맞게 잘렸는지 여부
- `system_code`: 선택적 문자열, 함수가 [제한](/production/state/limits.mdx#functions)에 접근할 때 자동으로 추가되는 경고에 존재

mutation에서 `console.log("Sent message!")`에 대한 예제 이벤트:

```json
{
    "topic": "console"
    "timestamp": 1715879172882,
    "function": {
      "path": "messages:send",
      "request_id": "d064ef901f7ec0b7",
      "type": "mutation"
    },
    "log_level": "LOG",
    "message": "'Sent message!'"
}
```

### `function_execution` 이벤트

함수가 실행될 때마다 발생하는 이벤트입니다.

스키마:

- `topic`: `"function_execution"`
- `timestamp`: 밀리초 단위의 Unix epoch 타임스탬프
- `function`: 객체, [함수 필드](/production/integrations/log-streams/log-streams.mdx#function-fields) 참조
- `execution_time_ms`: 숫자, 이 함수가 실행하는 데 걸린 시간(밀리초)
- `status`: 문자열, `["success", "failure"]` 중 하나
- `error_message`: 문자열, `failure` 상태의 함수에 존재하며 오류 및 스택 트레이스를 포함
- `mutation_queue_length`: 선택적 숫자(mutation만 해당), mutation이 실행된 시점의 세션별 mutation 큐 길이. 이는 개별 세션의 mutation 큐 백로그를 모니터링하고 디버깅하는 데 유용합니다.
- `mutation_retry_count`: 숫자, 성공하기 전에 실행된 이전 실패 횟수(mutation만 해당). mutation 및 action에만 적용됩니다.
- `occ_info`: 객체, 함수 호출이 OCC(두 함수 간의 쓰기 충돌)를 초래한 경우 이 필드가 존재하며 OCC와 관련된 정보를 포함합니다.
  [쓰기 충돌에 대해 자세히 알아보기](https://docs.convex.dev/error/#1).
  - `table_name`: 충돌이 발생한 테이블
  - `document_id`: 충돌하는 쓰기를 받은 문서의 ID
  - `write_source`: `table_name`에 대해 충돌하는 쓰기를 한 함수의 이름
  - `retry_count`: 현재 함수 실행 전의 이전 실패 시도 횟수
- `scheduler_info`: 객체, 설정되어 있으면 함수가 원래 [스케줄러](/scheduling/scheduled-functions)에 의해 호출되었음을 나타냅니다.
  - `job_id`: [`_scheduled_functions`](/scheduling/scheduled-functions#retrieving-scheduled-function-status) 테이블 내의 작업
- `usage`:
  - `database_read_bytes`: 숫자
  - `database_write_bytes`: 숫자, 이것과 `database_read_bytes`가 함수에서 사용하는 데이터베이스 대역폭을 구성합니다
  - `database_read_documents`: 숫자, 함수에서 읽은 문서 수
  - `file_storage_read_bytes`: 숫자
  - `file_storage_write_bytes`: 숫자, 이것과 `file_storage_read_bytes`가 함수에서 사용하는 파일 대역폭을 구성합니다
  - `vector_storage_read_bytes`: 숫자
  - `vector_storage_write_bytes`: 숫자, 이것과 `vector_storage_read_bytes`가 함수에서 사용하는 벡터 대역폭을 구성합니다
  - `memory_used_mb`: 숫자, 쿼리, mutation, action의 경우 MiB 단위로 사용된 메모리. 이것과 `execution_time_ms`가 컴퓨팅을 구성합니다.

쿼리에 대한 예제 이벤트:

```json
{
  "data": {
    "execution_time_ms": 294,
    "function": {
      "cached": false,
      "path": "message:list",
      "request_id": "892104e63bd39d9a",
      "type": "query"
    },
    "status": "success",
    "timestamp": 1715973841548,
    "topic": "function_execution",
    "usage": {
      "database_read_bytes": 1077,
      "database_write_bytes": 0,
      "database_read_documents": 3,
      "file_storage_read_bytes": 0,
      "file_storage_write_bytes": 0,
      "vector_storage_read_bytes": 0,
      "vector_storage_write_bytes": 0
    }
  }
}
```

### 함수 필드

모든 `console` 및 `function_execution` 이벤트의 `function` 아래에 다음 필드가 추가됩니다:

- `type`: 문자열, `["query", "mutation", "action", "http_action"]` 중 하나
- `path`: 문자열, 예: `"myDir/myFile:myFunction"` 또는 `"POST /my_endpoint"`
- `cached`: 선택적 불리언, 쿼리의 경우 이 이벤트가 캐시된 함수 실행에서 나왔는지 나타냅니다
- `request_id`: 문자열, 함수의 [요청 ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id)

### `scheduler_stats` 이벤트

예약된 함수 실행기의 통계를 보고하기 위해 주기적으로 전송되는 이벤트입니다.

스키마:

- `topic`: `"scheduler_stats"`
- `timestamp`: 밀리초 단위의 Unix epoch 타임스탬프
- `lag_seconds`: `timestamp`와 가장 오래된 지연된 예약 작업의 예정된 실행 시간 간의 차이(초)
- `num_running_jobs`: 숫자, 현재 실행 중인 예약 작업 수

### `audit_log` 이벤트

대시보드의 [History 탭](https://dashboard.convex.dev/deployment/history)에도 표시되는 배포 변경사항을 나타내는 이벤트입니다.

스키마:

- `topic`: `audit_log`
- `timestamp`: 밀리초 단위의 Unix epoch 타임스탬프
- `audit_log_action`: 문자열, 예: `"create_environment_variable"`, `"push_config"`, `"change_deployment_state"`
- `audit_log_metadata`: 문자열, 이벤트에 대한 메타데이터를 담고 있는 문자열화된 JSON. 이 이벤트의 정확한 형식은 변경될 수 있습니다.

`push_config` 감사 로그 예제:

```json
{
  "topic": "audit_log",
  "timestamp": 1714421999886,
  "audit_log_action": "push_config",
  "audit_log_metadata": "{\"auth\":{\"added\":[],\"removed\":[]},\"crons\":{\"added\":[],\"deleted\":[],\"updated\":[]},..."
}
```

## 보장

로그 이벤트는 최선의 전달 보장을 제공합니다. 로그 스트림은 메모리에 버퍼링되어 배치로 배포의 구성된 스트림으로 전송됩니다. 이는 수집 처리량이 너무 높으면 로그가 삭제될 수 있음을 의미합니다. 마찬가지로, 네트워크 재시도로 인해 로그 이벤트가 로그 스트림에 중복될 수 있습니다.

완료되었습니다! 이제 로그가 스트리밍되도록 구성되었습니다. 지원되기를 원하는 로그 스트리밍 대상이 있다면 [알려주세요](/production/contact.md)!

<StackPosts query="axiom" />
