---
title: Scheduled Functions
sidebar_position: 1
description: "Schedule functions to run in the future"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/messages.ts";

Convex를 사용하면 미래에 실행될 함수를 스케줄링할 수 있습니다. 이를 통해 큐나 다른 인프라를 설정하고 유지 관리할 필요 없이 강력한 내구성 있는 워크플로우를 구축할 수 있습니다.

스케줄링된 함수는 데이터베이스에 저장됩니다. 즉, 미래의 몇 분, 며칠, 심지어 몇 달 후에도 함수를 스케줄링할 수 있습니다. 스케줄링은 예상치 못한 다운타임이나 시스템 재시작에도 견고합니다.

**예제:**
[Scheduling](https://github.com/get-convex/convex-demos/tree/main/scheduling)

## 함수 스케줄링하기

mutation과 action에서 제공되는 [scheduler](/api/interfaces/server.Scheduler)를 통해 public 함수와 [internal 함수](/functions/internal-functions.mdx)를 스케줄링할 수 있습니다.

- [runAfter](/api/interfaces/server.Scheduler#runafter)는 지연 시간(밀리초 단위) 후에 실행되도록 함수를 스케줄링합니다.
- [runAt](/api/interfaces/server.Scheduler#runat)은 날짜 또는 타임스탬프(epoch 이후 경과된 밀리초)에 실행되도록 함수를 스케줄링합니다.

나머지 인수는 함수의 경로와 그 인수로, 클라이언트에서 함수를 호출하는 것과 유사합니다. 예를 들어, 다음은 5초 후에 자동으로 삭제되는 메시지를 보내는 방법입니다.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-runAfter"
  highlightPatterns={["scheduler", "runAfter"]}
/>

단일 함수는 총 인수 크기가 8MB인 최대 1000개의 함수를 스케줄링할 수 있습니다.

### mutation에서 스케줄링하기

[mutation](/functions/mutation-functions.mdx#transactions)에서 함수를 스케줄링하는 것은 mutation의 나머지 부분과 원자적입니다. 즉, mutation이 성공하면 스케줄링된 함수가 스케줄링되는 것이 보장됩니다. 반면에 mutation이 실패하면, 스케줄링 호출 후에 함수가 실패하더라도 어떤 함수도 스케줄링되지 않습니다.

### action에서 스케줄링하기

mutation과 달리 [action](/functions/actions.mdx)은 단일 데이터베이스 트랜잭션으로 실행되지 않으며 부작용을 가질 수 있습니다. 따라서 action에서의 스케줄링은 함수의 결과에 의존하지 않습니다. 즉, action이 일부 함수를 성공적으로 스케줄링한 후 일시적인 오류나 타임아웃으로 인해 나중에 실패할 수 있습니다. 그래도 스케줄링된 함수는 여전히 실행됩니다.

### 즉시 스케줄링하기

지연을 0으로 설정한 `runAfter()`는 이벤트 큐에 함수를 즉시 추가하는 데 사용됩니다. `setTimeout(fn, 0)`을 호출하는 데 익숙하다면 이 사용법에 익숙할 것입니다.

위에서 언급했듯이 action은 원자적이지 않으며 부작용을 일으키기 위한 것입니다. 즉시 스케줄링은 mutation이 성공하는 것을 조건으로 mutation에서 action을 트리거하려는 경우에 유용합니다. [이 게시물](https://stack.convex.dev/pinecone-and-embeddings#kick-off-a-background-action)은 애플리케이션이 외부 서비스에 의존하여 데이터베이스에 정보를 채우는 직접적인 예제를 다룹니다.

## 스케줄링된 함수 상태 조회하기

모든 스케줄링된 함수는 `"_scheduled_functions"` 시스템 테이블의 문서로 반영됩니다. `runAfter()`와 `runAt()`은 스케줄링된 함수의 id를 반환합니다. `db.system.get` 및 `db.system.query` 메서드를 사용하여 시스템 테이블에서 데이터를 읽을 수 있으며, 이는 표준 `db.get` 및 `db.query` 메서드와 동일하게 작동합니다.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-status"
  highlightPatterns={["system"]}
/>

다음은 반환된 문서의 예입니다:

```json
{
  "_creationTime": 1699931054642.111,
  "_id": "3ep33196167235462543626ss0scq09aj4gqn9kdxrdr",
  "args": [{}],
  "completedTime": 1699931054690.366,
  "name": "messages.js:destruct",
  "scheduledTime": 1699931054657,
  "state": { "kind": "success" }
}
```

반환된 문서에는 다음 필드가 있습니다:

- `name`: 스케줄링된 함수의 경로
- `args`: 스케줄링된 함수에 전달된 인수
- `scheduledTime`: 함수가 실행되도록 스케줄링된 시간의 타임스탬프(epoch 이후 경과된 밀리초)
- `completedTime`: 함수가 실행을 완료한 시간의 타임스탬프(완료된 경우, epoch 이후 경과된 밀리초)
- `state`: 스케줄링된 함수의 상태. 다음은 스케줄링된 함수가 가질 수 있는 상태입니다:
  - `Pending`: 함수가 아직 시작되지 않음
  - `InProgress`: 함수가 실행을 시작했지만 아직 완료되지 않음(action에만 적용)
  - `Success`: 함수가 오류 없이 성공적으로 실행을 완료함
  - `Failed`: 함수가 실행 중 오류를 발생시켰으며, 이는 사용자 오류 또는 내부 서버 오류일 수 있음
  - `Canceled`: 함수가 대시보드, `ctx.scheduler.cancel`을 통해 취소되었거나, 진행 중에 취소된 부모 스케줄링된 함수에 의해 재귀적으로 취소됨

스케줄링된 함수 결과는 완료 후 7일 동안 사용할 수 있습니다.

## 스케줄링된 함수 취소하기

이전에 스케줄링된 함수를 [`cancel`](/api/interfaces/server.Scheduler#cancel)을 통해 취소할 수 있으며, 해당 함수 컨텍스트에서 제공되는 [scheduler](/api/interfaces/server.Scheduler)를 사용합니다.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-cancel"
  highlightPatterns={["scheduler.cancel"]}
/>

`cancel`이 수행하는 작업은 스케줄링된 함수의 상태에 따라 다릅니다:

- 아직 실행을 시작하지 않은 경우, 실행되지 않습니다.
- 이미 시작한 경우, 계속 실행되지만 스케줄링하는 모든 함수는 실행되지 않습니다.

## 디버깅

Convex 대시보드 [로그 뷰](/dashboard/deployments/logs.md)에서 이전에 실행된 스케줄링된 함수의 로그를 볼 수 있습니다. [함수 뷰](/dashboard/deployments/functions.md)에서 아직 실행되지 않은 함수를 확인하고 취소할 수 있습니다.

## 에러 처리

일단 스케줄링되면 mutation은 정확히 한 번 실행되는 것이 보장됩니다. Convex는 내부 Convex 오류를 자동으로 재시도하며, 개발자 오류에 대해서만 실패합니다. 다양한 오류 유형에 대한 자세한 내용은 [에러 처리](/functions/error-handling/error-handling.mdx)를 참조하세요.

action은 부작용을 가질 수 있으므로 Convex에서 자동으로 재시도하지 않습니다. 따라서 action은 최대 한 번 실행되며, 실행 중 일시적인 오류가 있으면 영구적으로 실패합니다. 개발자는 원하는 결과가 달성되었는지 확인하는 mutation을 스케줄링하고, 그렇지 않은 경우 action을 다시 스케줄링하여 수동으로 재시도할 수 있습니다.

## 인증

인증은 스케줄링하는 함수에서 스케줄링된 함수로 전파되지 않습니다. 인증하거나 권한을 확인하려면 필요한 사용자 정보를 매개변수로 전달해야 합니다.
