---
title: "전체 텍스트 검색"
sidebar_position: 110
description: "Convex 문서에서 검색 쿼리 실행하기"
slug: "text-search"
---

전체 텍스트 검색을 사용하면 검색 쿼리와 대략적으로 일치하는 Convex 문서를 찾을 수 있습니다.

일반적인
[문서 쿼리](/database/reading-data/reading-data.mdx#querying-documents)와 달리,
검색 쿼리는 문자열 필드 _내부_를 살펴보고 키워드를 찾습니다. 검색 쿼리는
특정 단어가 포함된 메시지를 검색하는 것과 같은 기능을 구축하는 데 유용합니다.

검색 쿼리는 자동으로 반응형이고, 일관성 있고, 트랜잭션 방식이며, 페이지네이션과 원활하게 작동합니다. 심지어 mutation으로 생성된 새 문서도 포함됩니다!

**예제:**
[검색 앱](https://github.com/get-convex/convex-demos/tree/main/search)

전체 텍스트 검색을 사용하려면 다음이 필요합니다:

1. 검색 인덱스 정의하기.
2. 검색 쿼리 실행하기.

검색 인덱스는 Rust로 작성된 강력한 오픈 소스 전체 텍스트 검색 라이브러리인 [Tantivy](https://github.com/quickwit-oss/tantivy) 위에서 Convex의 다중 세그먼트 검색 알고리즘을 사용하여 구축되고 쿼리됩니다.

## 검색 인덱스 정의하기

[데이터베이스 인덱스](/database/reading-data/indexes/indexes.md)와 마찬가지로, 검색 인덱스는 효율적인 쿼리를 가능하게 하기 위해 미리 구축되는 데이터 구조입니다. 검색 인덱스는 Convex [스키마](/database/schemas.mdx)의 일부로 정의됩니다.

모든 검색 인덱스 정의는 다음으로 구성됩니다:

1. 이름.
   - 테이블당 고유해야 합니다.
2. `searchField`
   - 전체 텍스트 검색을 위해 인덱싱될 필드입니다.
   - `string` 타입이어야 합니다.
3. [선택사항] `filterField` 목록
   - 검색 인덱스 내에서 빠른 동등성 필터링을 위해 인덱싱되는 추가 필드입니다.
4. [선택사항] `staged` 플래그 (불리언)
   - `true`로 설정하면,
     [단계별 데이터베이스 인덱스](/database/reading-data/indexes#staged-indexes)와 유사하게 배포 시점부터 비동기적으로 인덱스가 백필됩니다.
     이는 인덱스 백필 시간이 중요한 대형 테이블에 유용합니다. 기본값은 `false`입니다.

테이블에 검색 인덱스를 추가하려면 테이블 스키마에서 [`searchIndex`](/api/classes/server.TableDefinition#searchindex) 메서드를 사용하세요. 예를 들어, 채널에서 키워드와 일치하는 메시지를 검색할 수 있는 인덱스를 원하는 경우, 스키마는 다음과 같습니다:

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  messages: defineTable({
    body: v.string(),
    channel: v.string(),
  }).searchIndex("search_body", {
    searchField: "body",
    filterFields: ["channel"],
    staged: false,
  }),
});
```

`properties.name`과 같은 점으로 구분된 경로를 사용하여 중첩된 문서에 검색 및 필터 필드를 지정할 수 있습니다.

## 검색 쿼리 실행하기

"'#general' 채널에서 본문이 'hello hi' 쿼리와 가장 잘 일치하는 10개의 메시지" 쿼리는 다음과 같습니다:

```js
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);
```

이것은 검색 인덱스를 쿼리하는 것으로 시작하는 일반적인 [데이터베이스 읽기](/database/reading-data/reading-data.mdx)일 뿐입니다!

[`.withSearchIndex`](/api/interfaces/server.QueryInitializer#withsearchindex)
메서드는 쿼리할 검색 인덱스와 Convex가 해당 검색 인덱스를 사용하여 문서를 선택하는 방법을 정의합니다. 첫 번째 인수는 인덱스의 이름이고 두 번째는 _검색 필터 표현식_입니다. 검색 필터 표현식은 쿼리를 실행할 때 Convex가 고려해야 하는 문서에 대한 설명입니다.

검색 필터 표현식은 항상 다음의 연결된 목록입니다:

1. [`.search`](/api/interfaces/server.SearchFilterBuilder#search)로 정의된 인덱스의 검색 필드에 대한 1개의 검색 표현식.
2. [`.eq`](/api/interfaces/server.SearchFilterFinalizer#eq)로 정의된 인덱스의 필터 필드에 대한 0개 이상의 동등성 표현식.

### 검색 표현식

검색 표현식은 검색 인덱스에 대해 발행되어 검색 표현식의 쿼리와의 관련성에 따라 문서를 필터링하고 순위를 매깁니다. 내부적으로 Convex는 쿼리를 개별 단어(_용어_라고 함)로 분해하고 이러한 용어와 일치하는 문서의 순위를 대략적으로 매깁니다.

위의 예에서 `search("body", "hello hi")` 표현식은 내부적으로 `"hi"`와 `"hello"`로 분할되어 문서의 단어와 일치합니다(대소문자와 구두점 무시).

검색 동작에는 [접두사 매칭 규칙](#search-behavior)이 포함됩니다.

### 동등성 표현식

검색 표현식과 달리, 동등성 표현식은 지정된 필드에 정확히 일치하는 문서만 필터링합니다. 위의 예에서 `eq("channel", "#general")`은 `channel` 필드에 정확히 `"#general"`이 있는 문서만 일치시킵니다.

동등성 표현식은 모든 타입의 필드를 지원합니다(텍스트만 아니라).

필드가 누락된 문서를 필터링하려면 `q.eq("fieldName", undefined)`를 사용하세요.

### 기타 필터링

검색 쿼리는 일반 데이터베이스 쿼리이므로 [`.filter` 메서드](/api/interfaces/server.Query#filter)를 사용하여 [결과를 필터링](/database/reading-data/filters.mdx)할 수도 있습니다!

다음은 "최근 10분 동안 전송된 'hi'가 포함된 메시지" 쿼리입니다:

```js
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) => q.search("body", "hi"))
  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))
  .take(10);
```

**성능을 위해 가능한 한 많은 필터를 `.withSearchIndex`에 넣으세요.**

모든 검색 쿼리는 다음과 같이 실행됩니다:

1. 먼저, `withSearchIndex`의 검색 필터 표현식을 사용하여 검색 인덱스를 쿼리합니다.
2. 그런 다음, 추가 `filter` 표현식을 사용하여 결과를 하나씩 필터링합니다.

매우 구체적인 검색 필터 표현식을 사용하면 Convex가 검색 인덱스를 사용하여 고려할 결과 수를 효율적으로 줄이기 때문에 쿼리가 더 빠르고 Convex의 제한에 도달할 가능성이 낮아집니다.

### 결과 검색 및 페이지네이션

일반 데이터베이스 쿼리와 마찬가지로 [`.collect()`](/api/interfaces/server.Query#collect), [`.take(n)`](/api/interfaces/server.Query#take), [`.first()`](/api/interfaces/server.Query#first), [`.unique()`](/api/interfaces/server.Query#unique)를 사용하여 [결과를 검색](/database/reading-data/reading-data.mdx#retrieving-results)할 수 있습니다.

또한 검색 결과는 [`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate)를 사용하여 [페이지네이션](/database/pagination.mdx)할 수 있습니다.

`collect()`는 1024개 이상의 문서를 수집하려고 하면 예외를 발생시킵니다. 더 작은 제한을 선택하고 `take(n)`를 사용하거나 결과를 페이지네이션하는 것이 더 나은 경우가 많습니다.

### 정렬

검색 쿼리는 항상 검색 쿼리와 문서가 얼마나 잘 일치하는지에 따라 [관련성 순서](#relevance-order)로 결과를 반환합니다. 다른 결과 정렬은 지원되지 않습니다.

## 검색 동작

### 자동 완성 검색

Convex 전체 텍스트 검색은 타이핑하면서 검색하는 경험을 제공하도록 설계되었습니다. 검색 쿼리에서 마지막 검색 용어는 _접두사 검색_이 활성화되어 원래 용어의 접두사인 모든 용어와 일치합니다. 예를 들어, `search("body", "r")` 표현식은 다음 문서와 일치합니다:

- `"rabbit"`
- `"send request"`

퍼지 검색 일치는 더 이상 사용되지 않습니다. 2025년 1월 15일 이후에는 `"stake"`와 같은 오타에 대해 검색 결과에 `"snake"`가 포함되지 않습니다.

### 관련성 순서

**관련성 순서는 변경될 수 있습니다.** 검색 결과의 관련성과 Convex가 적용하는 정확한 오타 허용 규칙은 검색 결과의 품질을 개선하기 위해 변경될 수 있습니다.

검색 쿼리는 관련성 순서로 결과를 반환합니다. 내부적으로 Convex는 [BM25 점수](https://en.wikipedia.org/wiki/Okapi_BM25)와 일치의 근접성, 정확한 일치 수 등 여러 다른 기준의 조합을 기반으로 문서의 관련성 순위를 매깁니다. BM25 점수는 다음을 고려합니다:

- 검색 쿼리의 몇 개 단어가 필드에 나타나는가?
- 얼마나 자주 나타나는가?
- 텍스트 필드의 길이는 얼마나 되는가?

여러 문서가 동일한 점수를 가진 경우, 가장 최신 문서가 먼저 반환됩니다.

## 제한사항

검색 인덱스는 영어 또는 다른 라틴 문자 언어에서 가장 잘 작동합니다. 텍스트는 Tantivy의
[`SimpleTokenizer`](https://docs.rs/tantivy/latest/tantivy/tokenizer/struct.SimpleTokenizer.html)를 사용하여 토큰화되며, 이는 공백과 구두점을 기준으로 분할합니다. 또한 용어를 최대 32자로 제한하고 소문자로 변환합니다.

검색 인덱스는 다음을 가져야 합니다:

- 정확히 1개의 검색 필드.
- 최대 16개의 필터 필드.

검색 인덱스는 [테이블당 32개 인덱스 제한](/database/reading-data/indexes/indexes.md#limits)에 포함됩니다.

검색 쿼리는 다음을 가질 수 있습니다:

- 검색 표현식에 최대 16개의 용어(단어).
- 최대 8개의 필터 표현식.

또한 검색 쿼리는 검색 인덱스에서 최대 1024개의 결과를 스캔할 수 있습니다.

이러한 제한사항의 진실의 원천은 [소스 코드](https://github.com/get-convex/convex-backend/blob/main/crates/search/src/constants.rs)입니다.

다른 제한사항에 대한 정보는 [여기](/production/state/limits.mdx)를 참조하세요.
