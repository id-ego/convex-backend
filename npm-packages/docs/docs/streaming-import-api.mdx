---
title: "Streaming Import"
sidebar_label: "Streaming Import"
description: "Streaming data into Convex"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Convex는 스트리밍 가져오기를 지원합니다. Convex는
[Airbyte](/production/integrations/streaming-import-export.md)를 위한 커넥터 구현을 제공합니다.
이러한 커넥터는 다음 API를 사용합니다.

스트리밍 가져오기 지원은 모든 Convex 프로젝트에 대해 자동으로 활성화됩니다.

스트리밍 가져오기 요청은 HTTP 헤더 `Authorization`을 통한 배포 관리자 권한이 필요합니다.
값은 `Convex <access_key>` 형식이며, 여기서 액세스 키는 Convex 대시보드의 "Deploy key"에서 가져오며
Convex 데이터에 대한 전체 읽기 및 쓰기 액세스 권한을 부여합니다.

### Headers

스트리밍 가져오기 엔드포인트는 `Convex-Client: streaming-import-<version>` 헤더를 허용하며,
여기서 버전은 [Semver](https://semver.org/) 지침을 따릅니다. 이 헤더가 지정되지 않으면
Convex는 기본적으로 최신 버전을 사용합니다. API가 변경됨에 따라 이 API의 소비자가 중단되지 않도록
헤더를 사용하는 것을 권장합니다.

### GET `/api/streaming_import/primary_key_indexes_ready`

`primary_key_indexes_ready` 엔드포인트는 테이블 이름 목록을 받아 해당 모든 테이블의
(`add_primary_key_indexes`로 생성된) 기본 키 인덱스가 준비되었는지 여부를 나타내는 true를 반환합니다.
테이블이 새로 생성된 경우 인덱스는 즉시 준비되어야 합니다. 그러나 테이블에 기존 문서가 있는 경우
기본 키 인덱스를 백필하는 데 시간이 걸릴 수 있습니다. 응답은 다음과 같습니다:

```json
{
  "indexesReady": true
}
```

### PUT `/api/streaming_import/add_primary_key_indexes`

`add_primary_key_indexes` 엔드포인트는 테이블의 기본 키를 포함하는 JSON 본문을 받아
백필될 기본 키에 대한 인덱스를 생성합니다. 인덱스가 즉시 쿼리 가능한 상태가 되는 것은 아니며,
기본 키 인덱스가 필요한 레코드로 `import_airbyte_records`를 호출하기 전에
`primary_key_indexes_ready` 엔드포인트를 폴링하여 True를 반환할 때까지 기다려야 합니다.
또한 Convex 쿼리는 이렇게 추가된 인덱스에 액세스할 수 없습니다. 이는 오직
`import_airbyte_records`에서 사용하기 위한 것입니다. 본문은 인덱스 이름을 인덱싱할 필드 경로 목록에
매핑하는 형태입니다. 각 필드 경로는 중첩된 필드 경로를 나타낼 수 있는 필드 목록으로 표현됩니다.

```json
{
  "indexes": {
    "<table_name>": [["<field1>"], ["<field2>", "<nested_field>"]]
  }
}
```

예상 API 사용법:

1. `add_primary_key_indexes`에 요청하여 기본 키에 대한 인덱스를 추가합니다.
2. 응답이 true가 될 때까지 `primary_key_indexes_ready`를 폴링합니다.
3. 추가된 인덱스를 사용하여 쿼리합니다.

### PUT `api/streaming_import/clear_tables`

`clear_tables` 엔드포인트는 지정된 테이블에서 모든 문서를 삭제합니다.
이는 여러 트랜잭션이 필요할 수 있습니다. 중간에 오류가 발생하면 일부 문서만 삭제될 수 있습니다.
이 API 요청을 사용하기 위한 JSON 본문은 테이블 이름 목록을 포함합니다:

```json
{
  "tableNames": ["<table_1>", "<table_2>"]
}
```

### POST `api/streaming_import/replace_tables`

이 엔드포인트는 더 이상 지원되지 않습니다. 대신 `api/streaming_import/clear_tables`를 사용하세요.

`replace_tables` 엔드포인트는 임시 이름을 가진 테이블을 최종 이름으로 변경하고,
최종 이름을 가진 기존 테이블을 삭제합니다.

이 API 요청을 사용하기 위한 JSON 본문은 테이블 이름 목록을 포함합니다:

```json
{
  "tableNames": { "<table_1_temp>": "<table_1>", "<table_2_temp>": "<table_2>" }
}
```

### POST `api/streaming_import/import_airbyte_records`

`import_airbyte_records` 엔드포인트는 Convex 배포로의 스트리밍 입력을 가능하게 하며
Airbyte destination 커넥터에서 호출되도록 설계되었습니다.

JSON 본문에서 스트림의 맵과 메시지 목록을 받습니다. 각 스트림은 Convex 테이블에 해당하는
이름과 JSON 스키마를 가집니다. 레코드가 중복 제거되어야 하는 스트림에는 기본 키도 포함되며,
이는 필드 경로인 문자열의 목록의 목록으로 표현됩니다. 기본 키가 없는 스트림의 레코드는 테이블에 추가되고,
기본 키가 있는 스트림의 레코드는 기본 키 값이 일치하는 기존 레코드를 대체하거나 일치하는 항목이 없으면
추가됩니다. 기본 키를 사용하는 경우, 먼저 `add_primary_key_indexes` 엔드포인트를 호출하고
`primary_key_indexes_ready`를 폴링하여 백필이 완료될 때까지 기다려야 합니다.

각 메시지에는 스트림 이름과 해당 스트림 이름을 가진 테이블에 삽입될(또는 중복 제거 동기화의 경우 대체될)
JSON 문서가 포함됩니다. 테이블 이름은 스트림 이름과 동일합니다. Airbyte 레코드는 Convex 문서가 됩니다.

```json
{
   "tables": {
      "<stream_name>": {
         "primaryKey": [["<field1>"], ["<field2>", "<nested_field>"]],
         "jsonSchema": // see https://json-schema.org/ for examples
      }
   },
   "messages": [{
      "tableName": "<table_name>",
      "data": {} // JSON object conforming to the `json_schema` for that stream
   }]
}
```

`clear_tables`와 유사하게, 트랜잭션이 커밋된 후 실패가 발생하면
`import_airbyte_records`를 사용하여 부분 가져오기를 실행할 수 있습니다.

예상 API 사용법:

1. [선택 사항] 기본 키를 사용하고
   [중복 제거 동기화](https://docs.airbyte.com/understanding-airbyte/connections/incremental-deduped-history/)를
   사용하는 경우 인덱스를 추가합니다(위의 `add_primary_key_indexes` 참조).
2. [선택 사항] [덮어쓰기 동기화](https://docs.airbyte.com/understanding-airbyte/connections/full-refresh-overwrite)를
   사용하는 경우 `clear_tables`를 사용하여 지정된 테이블의 모든 문서를 삭제합니다.
3. 동기화할 새 레코드와 스트림 정보로 `import_airbyte_records`에 요청합니다.
