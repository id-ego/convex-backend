---
title: "Convex 튜토리얼: 채팅 앱"
sidebar_label: "1. 채팅 앱"
sidebar_position: 100
hide_table_of_contents: true
pagination_next: tutorial/actions
pagination_label: "Convex 튜토리얼: 채팅 앱"
description:
  "쿼리, 뮤테이션, 그리고 연결된 모든 클라이언트에 자동 업데이트를 제공하는 동기화 엔진을 사용하여 Convex로 실시간 채팅 애플리케이션을 만드세요."
---

# Convex 튜토리얼: 채팅 앱

Convex는 클라우드 함수, 데이터베이스, 스케줄링, 그리고 프론트엔드와 백엔드를 실시간으로 최신 상태로 유지하는 동기화 엔진을 갖춘 완전한 기능의 백엔드를 제공합니다.

오늘은 **약 10줄의 코드**로 데이터베이스를 읽고 쓰며 채팅 앱의 모든 사용자를 자동으로 업데이트하는 백엔드를 만들어 보겠습니다.

그런 다음 외부 서비스에 연결하고 제품의 성공과 확장을 위한 설정 방법을 살펴보겠습니다.

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/608khv7qqOI?si=ce-M8pt6EWDZ8tfd"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

## Convex로 개발 시작하기

<Details summary="시작하기 전에: Node.js 18+ 및 Git이 필요합니다">

컴퓨터에 Node.js 버전 18 이상이 설치되어 있는지 확인하세요. 터미널에서 `node --version`을 실행하여 Node.js 버전을 확인할 수 있습니다.
적절한 버전의 Node.js가 설치되어 있지 않다면,
[Node.js 웹사이트에서 설치하세요.](https://nodejs.org/en)

또한, 이 튜토리얼에는 Git이 필요하므로 터미널에서 `git -v`를 실행하여 설치되어 있는지 확인하세요. 설치되어 있지 않다면,
[Git 웹사이트](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)에서 설치 방법을 확인하세요.

</Details>

먼저, GitHub에서 예제 프로젝트 저장소를 복제하고 종속성을 설치하세요:

```shell
git clone https://github.com/get-convex/convex-tutorial.git
cd convex-tutorial
npm install
```

이 앱의 `dev` npm 명령은 Convex를 설정한 다음 웹 앱을 실행합니다:

```shell
npm run dev
```

설정 중에 Convex가 인증을 위해 GitHub 계정을 사용하는 것을 볼 수 있습니다. GitHub로 Convex에 로그인한 다음 기본 프로젝트 설정 프롬프트를 수락하세요.

이렇게 하면 **자동으로 백엔드가 생성**되고 프로젝트에 `convex/`라는 폴더가 생성되며, 여기에 백엔드 코드를 작성하게 됩니다.

**이 튜토리얼 전체에서 이 명령(`npm run dev`)을 백그라운드에서 계속 실행하도록 하세요.** 프론트엔드용 개발 웹 서버와 백엔드를 로컬 코드베이스와 동기화 상태로 유지하기 위한 백그라운드의 `convex` 명령을 모두 실행하고 있습니다.

서버가 실행되면 [localhost:5173](http://localhost:5173)을 열어 확인하세요:

<div className="center-image" style={{ maxWidth: "676px" }}>
  ![채팅 UI](/img/tutorial/tut_chat_ui.png)
</div>

지금 메시지를 보내려고 하면, 뮤테이션이 아직 구현되지 않았다는 알림이 표시됩니다. 잠시 후에 그것을 할 것이지만, 먼저 Convex가 어떻게 작동하는지 간단히 요약하겠습니다.

## Convex 작동 방식

<div className="center-image" style={{ maxWidth: "700px" }}>
  ![동기화 엔진 개요](/img/tutorial/ConvexSyncEngine.png)
</div>

**데이터베이스.** Convex 데이터베이스는 문서-관계형 데이터베이스로, JSON과 같은 문서가 있는 테이블을 의미합니다. 모든 문서는 자동 생성된 `_id`를 가지고 있어 문서 간의 관계를 만드는 데 사용할 수 있습니다. TypeScript로 완전히 작성된 뮤테이션 및 쿼리 함수를 통해 데이터베이스와 상호 작용합니다.

**뮤테이션 함수.** 뮤테이션은 데이터베이스를 업데이트하는 TypeScript 함수입니다. Convex의 모든 뮤테이션 함수는 데이터베이스 트랜잭션으로 실행됩니다. 따라서 모든 변경 사항이 커밋되거나 아무것도 커밋되지 않습니다.

**쿼리 함수.** 쿼리는 데이터베이스에서 읽기만 할 수 있는 TypeScript 함수입니다. 잠시 후에 보겠지만, 프론트엔드에서 쿼리를 구독하여 앱을 자동으로 최신 상태로 유지합니다.

프론트엔드는 **클라이언트 라이브러리**를 통해 쿼리 업데이트를 수신하도록 등록합니다. 클라이언트 라이브러리는 빠른 실시간 업데이트를 위해 WebSocket을 통해 Convex와 통신합니다.

**동기화 엔진**은 쿼리가 읽는 데이터베이스의 문서에 대한 변경 사항을 포함하여 함수에 대한 입력이 변경될 때 쿼리 함수를 다시 실행합니다. 그런 다음 쿼리를 수신하는 모든 앱을 업데이트합니다. 동기화 엔진은 쿼리, 뮤테이션 및 데이터베이스의 조합입니다.

이제 코드로 들어가 보겠습니다!

## 첫 번째 `mutation`

`convex/` 폴더에 `chat.ts`라는 새 파일을 만드세요. 여기에 이 애플리케이션의 Convex 백엔드 함수를 작성할 것입니다.

**`convex/chat.ts` 파일에 다음을 추가하세요.**

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const sendMessage = mutation({
  args: {
    user: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("This TypeScript function is running on the server.");
    await ctx.db.insert("messages", {
      user: args.user,
      body: args.body,
    });
  },
});
```

이것을 분석해 보겠습니다:

1. `sendMessage`라는 새로운 백엔드 `mutation` 함수를 추가하고 공개 API로 노출했습니다.
1. 전체 함수는 예외가 발생하면 롤백되는 트랜잭션으로 자동 실행됩니다.
1. 이것은 단순한 TypeScript 함수이므로 `console.log` 라인을 추가하여 서버에서 간단한 디버깅을 할 수 있습니다.
1. `args:`는 함수 인수가 타입과 런타임 값 모두로 `user` 및 `body`라는 두 개의 문자열인지 확인합니다.
1. `ctx.db.insert`는 Convex에 새 메시지 문서를 테이블에 삽입하도록 지시합니다.

이제 이 뮤테이션을 웹 앱에 연결해 보겠습니다.

**`src/App.tsx` 파일을 다음과 같이 업데이트하세요:**

```tsx
// highlight-next-line
// Convex에서 `useMutation`과 `api`를 import하세요.
// highlight-next-line
import { useMutation } from "convex/react";
// highlight-next-line
import { api } from "../convex/_generated/api";

//...

export default function App() {
  // highlight-next-line
  // "TODO: Add mutation hook here."를 다음으로 교체하세요:
  // highlight-next-line
  const sendMessage = useMutation(api.chat.sendMessage);

  //...

  return (
    <main className="chat">
      {/* ... */}
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          // highlight-next-line
          // "alert("Mutation not implemented yet");"를 다음으로 교체하세요:
          // highlight-next-line
          await sendMessage({ user: NAME, body: newMessageText });

          setNewMessageText("");
        }}
      >
        {/* ... */}
      </form>
    </main>
  );
}
```

프론트엔드에서 뮤테이션을 호출하는 두 가지 단계가 있습니다:

1. `const sendMessage = useMutation(api.chat.sendMessage);`는 프론트엔드 앱에 뮤테이션 함수에 대한 핸들을 제공합니다
2. `await sendMessage({ user: NAME, body: newMessageText });`는 적절한 매개변수로 뮤테이션을 호출합니다.

이제 **Convex 대시보드를 열어볼** 좋은 시간입니다. 새 브라우저 창을 열고 [https://dashboard.convex.dev](https://dashboard.convex.dev)로 이동하여 새 `convex-tutorial` 프로젝트를 찾으세요.

**"Data" 화면으로 이동하세요**. 지금까지 데이터베이스에는 데이터가 없습니다.

**채팅 앱과 대시보드 창을 나란히 열어 두세요**. 이제 채팅 앱에서 메시지를 보내보세요.

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_first_mutation.mp4" type="video/mp4" />
  Convex 백엔드 및 데이터베이스에 연결된 뮤테이션.
</video>

`messages` 테이블에 새 채팅 메시지가 실시간으로 표시되는 것을 볼 수 있습니다.

첫 번째 메시지를 보낼 때 Convex가 자동으로 `messages` 테이블을 만들었습니다. Convex에서 [스키마](/database/schemas.mdx)는 선택 사항입니다. 결국에는 테이블 구조를 강제하고 싶겠지만, 튜토리얼을 위해서는 이것을 건너뛰겠습니다.

대시보드에서 [로그 화면](https://dashboard.convex.dev/deployment/logs)으로 이동하여 앞서 추가한 로그 라인과 함께 실행한 모든 뮤테이션 호출을 볼 수도 있습니다. 로그 화면은 개발 중 백엔드를 디버깅하는 데 중요한 부분입니다.

데이터베이스 트랜잭션이기도 한 `mutation` 함수를 성공적으로 만들고 UI에 연결했습니다.

이제 대시보드가 실시간으로 업데이트되는 것처럼 앱도 실시간으로 업데이트되도록 하겠습니다.

## 첫 번째 `query`

**`convex/chat.ts` 파일을 다음과 같이 업데이트하세요:**

```tsx
// highlight-next-line
// 다음과 같이 서버 import를 업데이트하세요:
// highlight-next-line
import { query, mutation } from "./_generated/server";

// ...

// highlight-next-line
// 다음 함수를 파일에 추가하세요:
// highlight-next-line
export const getMessages = query({
  // highlight-next-line
  args: {},
  // highlight-next-line
  handler: async (ctx) => {
    // highlight-next-line
    // 가장 최근 메시지를 먼저 가져옵니다
    // highlight-next-line
    const messages = await ctx.db.query("messages").order("desc").take(50);
    // highlight-next-line
    // 시간순으로 정렬하기 위해 목록을 역순으로 만듭니다.
    // highlight-next-line
    return messages.reverse();
    // highlight-next-line
  },
  // highlight-next-line
});
```

이것을 분석해 보겠습니다:

1. `getMessages`라는 새로운 백엔드 `query` 함수를 추가하고 공개 API로 노출했습니다.
1. 이것은 쿼리 함수이므로, 이 함수의 `ctx.db`는 데이터만 읽을 수 있습니다.
1. `handler`의 첫 번째 라인에서 최신 것부터 오래된 것 순으로 가장 최근 50개의 메시지를 쿼리합니다.
1. 두 번째 라인에서는 평범한 TypeScript를 사용하여 목록을 역순으로 만듭니다.

**이제 `src/App.tsx`를 업데이트하여 쿼리에서 읽도록 하세요:**

```tsx
// highlight-next-line
// convex/react import를 다음과 같이 업데이트하세요:
// highlight-next-line
import { useQuery, useMutation } from "convex/react";

//...

export default function App() {
  // highlight-next-line
  // `const messages = ...` 라인을 다음으로 교체하세요
  // highlight-next-line
  const messages = useQuery(api.chat.getMessages);

  //...
}
```

하나의 `useQuery` 라인이 자동으로 많은 작업을 수행합니다. Convex 클라이언트 라이브러리에 `getMessages` 함수를 구독하라고 지시합니다. 표시할 새 메시지가 있을 때마다 쿼리 함수가 자동으로 다시 실행됩니다. 결과는 `const messages` 변수에 저장되고 React가 UI 컴포넌트를 다시 렌더링하여 최신 메시지를 표시합니다.

이것으로 끝입니다. 이제 앱으로 돌아가서 메시지를 보내보세요.

앱에 새 메시지가 도착하면 실시간 업데이트가 표시되어야 합니다:

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_first_query.mp4" type="video/mp4" />
  쿼리가 연결되어 앱에 실시간 업데이트됩니다.
</video>

<br />
<br />
믿어지지 않나요? 두 개의 채팅 창을 나란히 열고 메시지를 보내보세요:

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_side_by_side.mp4" type="video/mp4" />
  실시간 동기화 채팅 앱.
</video>

## 만든 것

단 몇 줄의 코드로 실시간 업데이트되는 채팅 앱을 만들었습니다.

1. 트랜잭션에서 데이터베이스에 새 채팅 메시지를 추가하는 `mutation` TypeScript 함수를 만들었습니다.
1. 최신 데이터로 앱을 업데이트하는 `query` TypeScript 함수를 만들었습니다.
1. 프론트엔드를 백엔드와 실시간으로 동기화 상태로 유지하는 클라이언트 라이브러리를 사용했습니다.

Convex의 기본 사항과 모든 것을 구동하는 동기화 엔진을 배웠습니다.

## 다음 단계

이 튜토리얼에서는 매우 기본적인 내용만 다뤘습니다. 여기서 멈추고 [인덱스를 통한 효율적인 쿼리](/database/reading-data/indexes/indexes.md) 및 [조인을 통한 관계 탐색](/database/reading-data/reading-data.mdx#join)을 포함한 나머지 문서를 탐색해도 괜찮습니다. Convex가 어떻게 작동하는지 깊이 있게 알고 싶다면, 이 [훌륭한 심층 분석](https://stack.convex.dev/how-convex-works)을 읽어볼 수 있습니다.

하지만 외부 서비스를 호출하고 정교한 백엔드 워크플로우를 구축하는 방법을 보고 싶다면, [다음 섹션 →](/tutorial/actions.mdx)으로 넘어가세요.

<CardLink
  className="convex-hero-card"
  item={{
    href: "/tutorial/actions",
    docId: "tutorial/actions",
    label: "외부 서비스 호출하기",
  }}
/>
