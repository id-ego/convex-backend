---
title: "Convex Overview"
hidden: false
sidebar_position: 100
pagination_next: understanding/workflow
description:
  "Introduction to Convex - the reactive database with TypeScript queries"
---

Convex는 쿼리가 데이터베이스에서 바로 실행되는 TypeScript 코드인 오픈 소스 반응형 데이터베이스입니다. React 컴포넌트가 상태 변경에 반응하는 것처럼, Convex 쿼리는 데이터베이스 변경에 반응합니다.

Convex는 데이터베이스, 서버 함수를 작성할 수 있는 장소, 클라이언트 라이브러리를 제공합니다. 이를 통해 동적이고 실시간으로 업데이트되는 앱을 쉽게 구축하고 확장할 수 있습니다.

다음 다이어그램은 Convex가 가능하게 하는 표준 3계층 앱 아키텍처를 보여줍니다. 이 다이어그램의 맨 아래에서 시작하여 맨 위로 올라갑니다.

<div
  className="center-image"
  style={{ maxWidth: "600px", background: "white", borderRadius: "10px" }}
>
  ![Convex in your app](/img/basic-diagram.png)
</div>

## 데이터베이스

[데이터베이스](/database.mdx)는 Convex의 핵심입니다. Convex 데이터베이스는 프로젝트를 생성할 때 자동으로 프로비저닝됩니다. 연결 설정이나 클러스터 관리가 필요 없습니다.

<Admonition type="info">
  Convex에서 데이터베이스 쿼리는 [서버 함수](/functions.mdx)에 작성된 [TypeScript 코드](/database/reading-data/reading-data.mdx)입니다. 작성할 SQL이 없습니다. 필요한 ORM이 없습니다.
</Admonition>

Convex 데이터베이스는 반응형입니다. 쿼리가 의존하는 데이터가 변경될 때마다 쿼리가 다시 실행되고 클라이언트 구독이 업데이트됩니다.

Convex는 "문서-관계형" 데이터베이스입니다. "문서"는 JSON과 유사한 중첩된 객체를 데이터베이스에 넣는다는 의미입니다. "관계형"은 ID를 사용하여 다른 테이블의 문서를 참조하는 `user`에게 할당된 `tasks`와 같은 관계가 있는 테이블이 있다는 의미입니다.

Convex 클라우드 제공은 MySQL을 지속성 레이어로 사용하는 Amazon RDS 위에서 실행됩니다. 오픈 소스 버전은 SQLite, Postgres 및 MySQL을 사용합니다. 데이터베이스는 ACID를 준수하며 [직렬화 가능한 격리 및 낙관적 동시성 제어](/database/advanced/occ.md)를 사용합니다. 즉, Convex는 가장 엄격한 트랜잭션 보장을 제공하며, 일관성 없는 데이터를 절대 볼 수 없습니다.

## 서버 함수

새 Convex 프로젝트를 생성하면 [서버 함수](/functions.mdx)를 작성하는 `convex/` 폴더가 자동으로 생성됩니다. 이곳은 모든 백엔드 애플리케이션 로직과 데이터베이스 쿼리 코드가 있는 곳입니다.

데이터베이스를 읽고(쿼리) 쓰는(뮤테이션) TypeScript 서버 함수의 예:

```typescript title="convex/tasks.ts"
// Convex 쿼리 함수
export const getAllOpenTasks = query({
  args: {},
  handler: async (ctx, args) => {
    // 완료되지 않은 모든 항목을 가져오기 위해 데이터베이스 쿼리
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("by_completed", (q) => q.eq("completed", false))
      .collect();
    return tasks;
  },
});

// Convex 뮤테이션 함수
export const setTaskCompleted = mutation({
  args: { taskId: v.id("tasks"), completed: v.boolean() },
  handler: async (ctx, { taskId, completed }) => {
    // TypeScript를 사용하여 데이터베이스 업데이트
    await ctx.db.patch(taskId, { completed });
  },
});
```

쿼리 또는 뮤테이션 함수를 통해 데이터베이스를 읽고 씁니다.
[쿼리 함수](/functions/query-functions.mdx)는 데이터베이스에서만 읽을 수 있는 순수 함수입니다.
[뮤테이션 함수](/functions/mutation-functions.mdx)는 데이터베이스에서 읽거나 쓸 수 있는 트랜잭션입니다. 이 두 데이터베이스 함수는 트랜잭션 보장을 위해 네트워크 요청과 같은 [비결정적 작업을 수행할 수 없습니다](/functions/runtimes.mdx#restrictions-on-queries-and-mutations).

<Admonition type="info">
  전체 Convex 뮤테이션 함수는 트랜잭션입니다. 작성할 `begin` 또는 `end` 트랜잭션 문이 없습니다. Convex는 충돌 시 함수를 자동으로 재시도하며, 아무것도 관리할 필요가 없습니다.
</Admonition>

Convex는 액션이라는 표준 범용 서버리스 함수도 제공합니다. [액션 함수](/functions/actions.mdx)는 네트워크 요청을 할 수 있습니다. 데이터베이스를 읽고 쓰려면 쿼리 또는 뮤테이션 함수를 호출해야 합니다. LLM을 호출하거나 이메일을 보내는 데 액션을 사용합니다.

[스케줄러](scheduling/scheduled-functions.mdx) 또는 [cron 작업](scheduling/cron-jobs.mdx)을 통해 Convex 함수를 영구적으로 스케줄할 수도 있습니다. 스케줄링을 사용하면 하루 후에 새 사용자가 온보딩 작업을 수행하지 않은 경우 이메일을 보내는 것과 같은 워크플로를 구축할 수 있습니다.

[클라이언트 라이브러리](/client/react.mdx)를 통해 또는 [HTTP](/http-api/index.md#functions-api)를 통해 직접 Convex 함수를 호출합니다.

## 클라이언트 라이브러리

Convex 클라이언트 라이브러리는 프론트엔드를 서버 함수의 결과와 동기화된 상태로 유지합니다.

```tsx
// React 컴포넌트에서
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function TaskList() {
  const data = useQuery(api.tasks.getAllOpenTasks);
  return data ?? "Loading...";
}
```

로컬 상태가 변경될 때 React 컴포넌트를 업데이트하는 `useState` 훅처럼, Convex `useQuery` 훅은 쿼리 결과가 변경될 때마다 컴포넌트를 자동으로 업데이트합니다. 수동 구독 관리나 상태 동기화가 필요 없습니다.

쿼리 함수를 호출할 때 클라이언트 라이브러리는 함수의 결과를 구독합니다. Convex는 데이터베이스에서 읽은 데이터를 포함하여 쿼리 함수의 종속성을 추적합니다. 데이터베이스의 관련 데이터가 변경될 때마다 Convex는 자동으로 쿼리를 다시 실행하고 결과를 클라이언트에 보냅니다.

클라이언트 라이브러리는 서버에 보낼 뮤테이션을 메모리에 대기열에 넣습니다. 뮤테이션이 실행되고 쿼리 결과가 업데이트되면 클라이언트 라이브러리는 앱 상태를 일관성 있게 유지합니다. 데이터베이스의 동일한 논리적 시점에 대한 모든 구독을 업데이트합니다.

Convex는 거의 모든 인기 있는 웹 및 네이티브 앱 프레임워크에 대한 클라이언트 라이브러리를 제공합니다. 클라이언트 라이브러리는 WebSocket을 통해 Convex 배포에 연결합니다. 그런 다음 [라이브러리를 통해](/client/react.mdx#fetching-data) 공개 Convex 함수를 호출할 수 있습니다. [HTTP를 직접](/http-api/index.md#functions-api) 사용하여 Convex를 사용할 수도 있지만, 자동 구독을 받지 못합니다.

## 모든 것을 함께 사용하기

앞서 설명한 완료되지 않은 모든 작업을 가져오는 `getAllOpenTasks` Convex 쿼리 함수로 돌아가 보겠습니다:

```typescript title="convex/tasks.ts"
export const getAllOpenTasks = query({
  args: {},
  handler: async (ctx, args) => {
    // 완료되지 않은 모든 항목을 가져오기 위해 데이터베이스 쿼리
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("by_completed", (q) => q.eq("completed", false))
      .collect();
    return tasks;
  },
});
```

이 쿼리를 구독할 때 무슨 일이 일어나는지 따라가 보겠습니다:

<div
  className="center-image"
  style={{ maxWidth: "1800px", background: "white", borderRadius: "10px" }}
>
  ![Convex data flow](/img/convex-query-subscription.png)
</div>

웹 앱은 `useQuery` 훅을 사용하여 이 쿼리를 구독하고, 초기 값을 얻기 위해 다음과 같은 일이 발생합니다:

- Convex 클라이언트가 Convex 서버에 쿼리를 구독하라는 메시지를 보냅니다
- Convex 서버가 함수를 실행하고, 데이터베이스에서 데이터를 읽습니다
- Convex 서버가 함수의 결과를 클라이언트에 메시지로 보냅니다

이 경우 초기 결과는 다음과 같습니다 (1):

```json
[
  { _id: "e4g", title: "Grocery shopping", complete: false },
  { _id: "u9v", title: "Plant new flowers", complete: false },
];
```

그런 다음 뮤테이션을 사용하여 항목을 완료로 표시합니다 (2). 그러면 Convex가 쿼리를 다시 실행하여 (3) 업데이트된 결과를 얻습니다. 그리고 WebSocket 연결을 통해 웹 앱에 결과를 푸시합니다 (4):

```json
[
  { _id: "e4g", title: "Grocery shopping", complete: false },
];
```

## 반응성을 넘어서

반응성을 넘어서 Convex의 아키텍처는 더 깊은 이유로 중요합니다. Convex는 앱이 스택의 어느 계층에서도 일관성 없는 상태를 가지지 못하게 합니다.

이를 설명하기 위해 전자 상거래 스토어의 쇼핑 카트를 구축한다고 가정해 봅시다.

<div className="center-image" style={{ maxWidth: "600px" }}>
  ![Convex in your app](/img/convex-swaghaus.png)
</div>

제품 목록 페이지에는 두 개의 숫자가 있는데, 하나는 재고에 남아 있는 항목 수를 표시하고 다른 하나는 쇼핑 카트에 있는 항목 수를 표시합니다. 각 숫자는 다른 쿼리 함수의 결과입니다.

"장바구니에 추가" 버튼을 누를 때마다 재고에서 항목 하나를 제거하고 쇼핑 카트에 추가하는 뮤테이션이 호출됩니다.

카트를 변경하는 뮤테이션은 트랜잭션에서 실행되므로 데이터베이스는 항상 일관된 상태입니다. 반응형 데이터베이스는 재고 항목 수와 쇼핑 카트의 항목 수를 표시하는 쿼리가 모두 업데이트되어야 한다는 것을 알고 있습니다. 쿼리가 무효화되고 다시 실행됩니다. 결과는 WebSocket 연결을 통해 웹 앱으로 푸시됩니다.

클라이언트 라이브러리는 두 쿼리가 데이터베이스의 단일 시점을 반영하므로 웹 앱에서 동시에 업데이트되도록 합니다. 숫자가 맞지 않는 순간은 절대 없습니다. 앱은 항상 일관된 데이터를 표시합니다.

이 예제는 [Swaghaus 샘플 앱](https://swaghaus.biz/)에서 실제로 볼 수 있습니다.

## 인간과 AI가 생성한 코드를 위해

Convex는 강력한 보장을 제공하는 작고 구성 가능한 추상화 세트를 중심으로 설계되어, 팀원이나 LLM이 작성했든 상관없이 코드를 더 빠르게 작성할 수 있을 뿐만 아니라 읽고 유지 관리하기도 더 쉽습니다. 주요 기능은 버그 없는 AI 생성 코드를 얻을 수 있도록 합니다:

1. **쿼리는 TypeScript입니다** 데이터베이스 쿼리는 엔드투엔드 타입 안전성 및 IDE 지원을 제공하는 순수 TypeScript 함수입니다. 이는 AI가 SQL로 전환하지 않고도 TypeScript 코드의 대규모 학습 세트를 사용하여 데이터베이스 코드를 생성할 수 있음을 의미합니다.
1. **동일한 작업에 더 적은 코드** Convex에 의해 자동으로 관리되는 인프라와 보일러플레이트가 너무 많기 때문에 작성할 코드가 적고, 따라서 잘못될 코드도 적습니다.
1. **자동 반응성** 반응 시스템은 데이터 종속성을 자동으로 추적하고 UI를 업데이트합니다. AI는 구독, WebSocket 연결 또는 복잡한 상태 동기화를 수동으로 관리할 필요가 없으며, Convex가 이 모든 것을 자동으로 처리합니다.
1. **트랜잭션 보장** 쿼리는 읽기 전용이며 뮤테이션은 트랜잭션에서 실행됩니다. 이러한 제약 조건으로 인해 AI가 데이터를 손상시키거나 앱을 일관성 없는 상태로 만들 수 있는 코드를 작성하는 것은 거의 불가능합니다.

이러한 기능을 함께 사용하면 AI가 비즈니스 로직에 집중할 수 있고 Convex의 보장이 일반적인 실패 모드를 방지합니다.

## 더 알아보기

Convex가 이 모든 것을 어떻게 수행하는지에 대한 세부 정보가 궁금하다면 Convex 공동 창립자 Sujay의 훌륭한
[How Convex Works](https://stack.convex.dev/how-convex-works) 블로그 게시물을 읽을 수 있습니다.

이제 Convex가 앱에 어떻게 맞는지 잘 알았으므로, Convex 앱을 설정하고 시작하는 전체 워크플로를 살펴보겠습니다.
